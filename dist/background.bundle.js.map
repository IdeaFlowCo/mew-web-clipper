{
  "version": 3,
  "sources": ["../utils/logger.ts", "../MewService.ts", "../mewClipper.ts", "../services/YouTubeService.ts", "../background.ts"],
  "sourcesContent": ["export class Logger {\n    private context: string;\n    constructor(context: string) {\n        this.context = context;\n    }\n    info(...args: unknown[]): void {\n        console.log(`[INFO] [${this.context}]`, ...args);\n    }\n    error(...args: unknown[]): void {\n        console.error(`[ERROR] [${this.context}]`, ...args);\n    }\n}\n", "import { Logger } from \"./utils/logger.js\";\n\nexport const AUTH_CONFIG = {\n    baseUrl: \"https://mew-edge.ideaflow.app/api\",\n    baseNodeUrl: \"https://mew-edge.ideaflow.app/\",\n    auth0Domain: \"ideaflow-mew-dev.us.auth0.com\",\n    auth0ClientId: \"zbhouY8SmHtIIJSjt1gu8TR3FgMsgo3J\",\n    auth0ClientSecret:\n        \"x0SAiFCCMwfgNEzU29KFh3TR4sTWuQVDqrRwBWCe0KsbA7WEd-1Ypatb47LCQ_Xb\",\n    auth0Audience: \"https://ideaflow-mew-dev.us.auth0.com/api/v2/\",\n    // userId: \"auth0|6793c6489ed96468672bae93\",\n    // userId: \"auth0|67b00414a18956f5273397da\", // cody+mewagent@ideaflow.io\n};\n\nconst logger = new Logger(\"MewService\");\n\n/* MewService.ts - Tailored for our conversation integration project */\n\nexport interface ConversationNode {\n    id: string;\n    parentNodeId: string;\n    text: string;\n    createdAt: string;\n}\n\nexport enum NodeContentType {\n    Text = \"text\",\n    Replacement = \"replacement\",\n    Mention = \"mention\",\n}\n\nexport interface ReplacementNodeData {\n    referenceNodeId: string;\n    referenceCanonicalRelationId: string;\n}\n\nexport interface MentionData {\n    preMentionText: string;\n    postMentionText: string;\n    mentionNodeId: string;\n}\n\nexport type NodeContent =\n    | { type: NodeContentType.Text; text: string }\n    | {\n          type: NodeContentType.Replacement;\n          replacementNodeData: ReplacementNodeData;\n      }\n    | { type: NodeContentType.Mention; mentionData: MentionData };\n\nexport function createNodeContent(content: any) {\n    // If content is already in the correct format, return it\n    if (Array.isArray(content)) {\n        return content;\n    }\n\n    // Handle our NodeContent type\n    if (content.type === NodeContentType.Text) {\n        return [{ type: \"text\", value: content.text, styles: 0 }];\n    } else if (content.type === \"text\" && content.text) {\n        // Handle the format coming from mewClipper\n        return [{ type: \"text\", value: content.text, styles: 0 }];\n    } else if (content.type === NodeContentType.Mention) {\n        return [\n            {\n                type: \"text\",\n                value: content.mentionData.preMentionText,\n                styles: 0,\n            },\n            {\n                type: \"mention\",\n                value: content.mentionData.mentionNodeId,\n                mentionTrigger: \"@\",\n            },\n            {\n                type: \"text\",\n                value: content.mentionData.postMentionText,\n                styles: 0,\n            },\n        ];\n    } else if (content.type === NodeContentType.Replacement) {\n        return [{ type: \"text\", value: \"replacement\", styles: 0 }];\n    }\n\n    // Default case\n    return [{ type: \"text\", value: \"\", styles: 0 }];\n}\n\nexport class MewAPI {\n    private baseUrl: string;\n    private baseNodeUrl: string;\n    private token: string;\n    private currentUserId: string;\n\n    constructor() {\n        // Use the base URL from our AUTH_CONFIG\n        this.baseUrl = AUTH_CONFIG.baseUrl;\n        this.baseNodeUrl = AUTH_CONFIG.baseNodeUrl;\n        this.token = \"\";\n        this.currentUserId = \"\"; // Will be set from user's root node URL\n    }\n\n    public setCurrentUserId(userId: string): void {\n        this.currentUserId = userId;\n    }\n\n    public getCurrentUser(): { id: string } {\n        return { id: this.currentUserId };\n    }\n\n    private uuid(): string {\n        return crypto.randomUUID();\n    }\n\n    async getAccessToken(): Promise<string> {\n        // Retrieve an access token using Auth0 credentials.\n        try {\n            const response = await fetch(\n                `https://${AUTH_CONFIG.auth0Domain}/oauth/token`,\n                {\n                    method: \"POST\",\n                    mode: \"cors\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({\n                        client_id: AUTH_CONFIG.auth0ClientId,\n                        client_secret: AUTH_CONFIG.auth0ClientSecret,\n                        audience: AUTH_CONFIG.auth0Audience,\n                        grant_type: \"client_credentials\",\n                    }),\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`Auth failed: ${response.statusText}`);\n            }\n\n            const data = await response.json();\n            this.token = data.access_token;\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                logger.error(\"Failed to fetch access token:\", error);\n            } else {\n                logger.error(\"Failed to fetch access token: Unknown error\");\n            }\n            // Fallback to a dummy token if necessary\n            this.token = \"dummy-access-token\";\n        }\n        return this.token;\n    }\n\n    async addNode(input: {\n        content: any;\n        parentNodeId?: string;\n        relationLabel?: string;\n        isChecked?: boolean;\n        authorId?: string;\n    }): Promise<{\n        newNodeId: string;\n        newRelationLabelNodeId: string;\n        parentChildRelationId: string;\n        referenceNodeId: string;\n        referenceCanonicalRelationId: string;\n        isChecked?: boolean;\n    }> {\n        const { content, parentNodeId, relationLabel, isChecked, authorId } =\n            input;\n        const nodeContent = createNodeContent(content);\n        const usedAuthorId = authorId ?? this.currentUserId;\n        const newNodeId = this.uuid();\n        const parentChildRelationId = this.uuid();\n        const transactionId = this.uuid();\n        const timestamp = Date.now();\n        let relationLabelNodeId = \"\";\n\n        const updates: any[] = [];\n\n        // Step 1: Add the new node.\n        updates.push({\n            operation: \"addNode\",\n            node: {\n                version: 1,\n                id: newNodeId,\n                authorId: usedAuthorId,\n                createdAt: timestamp,\n                updatedAt: timestamp,\n                content: nodeContent,\n                isPublic: true,\n                isNewRelatedObjectsPublic: false,\n                canonicalRelationId: parentNodeId\n                    ? parentChildRelationId\n                    : null,\n                isChecked: isChecked ?? null,\n                accessMode: 0,\n                attributes: {\n                    isAiGenerated: false,\n                    isUnconfirmed: false,\n                },\n            },\n        });\n\n        // Step 2: If a parent is provided, establish the child relation.\n        if (parentNodeId) {\n            updates.push({\n                operation: \"addRelation\",\n                relation: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                fromPos: { int: timestamp, frac: \"a0\" },\n                toPos: { int: timestamp, frac: \"a0\" },\n            });\n            // Single updateRelationList operation for the parent-child relation\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: parentChildRelationId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentNodeId,\n                relatedNodeId: newNodeId,\n            });\n        }\n\n        // Step 3: Optionally create a relation label node if a relationLabel is provided.\n        if (relationLabel) {\n            relationLabelNodeId = this.uuid();\n            updates.push({\n                operation: \"addNode\",\n                node: {\n                    version: 1,\n                    id: relationLabelNodeId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    content: [\n                        { type: \"text\", value: relationLabel, styles: 0 },\n                    ],\n                    isPublic: true,\n                    isNewRelatedObjectsPublic: false,\n                    canonicalRelationId: null,\n                    isChecked: null,\n                    accessMode: 0,\n                    attributes: {\n                        isAiGenerated: false,\n                        isUnconfirmed: false,\n                    },\n                },\n            });\n            const newRelationTypeId = this.uuid();\n            updates.push({\n                operation: \"addRelation\",\n                relation: {\n                    version: 1,\n                    id: newRelationTypeId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentChildRelationId,\n                    toId: relationLabelNodeId,\n                    relationTypeId: \"__type__\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                fromPos: { int: timestamp, frac: \"a0\" },\n                toPos: { int: timestamp, frac: \"a0\" },\n            });\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: newRelationTypeId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentChildRelationId,\n                relatedNodeId: relationLabelNodeId,\n            });\n            // Update the original child relation to reference the new relation type\n            updates.push({\n                operation: \"updateRelation\",\n                oldProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                newProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: newRelationTypeId,\n                },\n            });\n        }\n\n        // Step 4: If the content type is Replacement, update the parent-child relation accordingly.\n        if (content?.type === \"Replacement\" && content.replacementNodeData) {\n            updates.push({\n                operation: \"updateRelation\",\n                oldProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                newProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: content.replacementNodeData.referenceNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId:\n                        content.replacementNodeData\n                            .referenceCanonicalRelationId,\n                },\n            });\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: parentChildRelationId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentNodeId,\n                relatedNodeId: content.replacementNodeData.referenceNodeId,\n            });\n        }\n\n        // Step 5: Execute one transaction with all updates.\n        const token = await this.getAccessToken();\n        const payload = {\n            clientId: AUTH_CONFIG.auth0ClientId,\n            userId: usedAuthorId,\n            transactionId: transactionId,\n            updates: updates,\n        };\n\n        let txResponse;\n        try {\n            txResponse = await fetch(`${this.baseUrl}/sync`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${token}`,\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(payload),\n                signal: AbortSignal.timeout(10000), // 10 second timeout\n            });\n        } catch (error: unknown) {\n            // Handle network errors, timeouts, etc.\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            const errMsg = `Network error when connecting to API: ${errorMessage}`;\n            logger.error(errMsg);\n            logger.error(\"Request payload was:\", payload);\n            \n            return {\n                newNodeId: this.uuid(),\n                newRelationLabelNodeId: \"\",\n                parentChildRelationId: parentChildRelationId,\n                referenceNodeId: \"\",\n                referenceCanonicalRelationId: \"\",\n                isChecked: isChecked ?? undefined,\n            };\n        }\n\n        if (!txResponse.ok) {\n            const responseText = await txResponse.text();\n            const errMsg = `Failed to add node: Status ${txResponse.status} ${txResponse.statusText}. Response: ${responseText}`;\n            logger.error(errMsg);\n            logger.error(\"Request payload was:\", payload);\n            \n            return {\n                newNodeId: this.uuid(),\n                newRelationLabelNodeId: \"\",\n                parentChildRelationId: parentChildRelationId,\n                referenceNodeId: \"\",\n                referenceCanonicalRelationId: \"\",\n                isChecked: isChecked ?? undefined,\n            };\n        }\n\n        if (txResponse.ok && isChecked) {\n            // Optionally update the node's isChecked status.\n            // await this.updateNode(newNodeId, { isChecked: true });\n        }\n\n        return {\n            newNodeId,\n            newRelationLabelNodeId: relationLabelNodeId,\n            parentChildRelationId,\n            referenceNodeId:\n                content?.type === \"Replacement\" && content.replacementNodeData\n                    ? content.replacementNodeData.referenceNodeId\n                    : \"\",\n            referenceCanonicalRelationId:\n                content?.type === \"Replacement\" && content.replacementNodeData\n                    ? content.replacementNodeData.referenceCanonicalRelationId\n                    : \"\",\n            isChecked: isChecked ?? undefined,\n        };\n    }\n\n    async syncData(): Promise<any> {\n        const token = await this.getAccessToken();\n        try {\n            const response = await fetch(`${this.baseUrl}/sync`, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${token}`,\n                    \"Content-Type\": \"application/json\",\n                },\n                signal: AbortSignal.timeout(10000), // 10 second timeout\n            });\n            \n            if (!response.ok) {\n                logger.error(`Failed to sync data: ${response.statusText}`);\n                return { data: { usersById: {}, nodesById: {}, relationsById: {} } };\n            }\n            \n            return response.json();\n        } catch (error: unknown) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error(`Network error when syncing data: ${errorMessage}`);\n            return { data: { usersById: {}, nodesById: {}, relationsById: {} } };\n        }\n    }\n\n    async getLayerData(objectIds: string[]): Promise<any> {\n        const token = await this.getAccessToken();\n        try {\n            const response = await fetch(`${this.baseUrl}/layer`, {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${token}`,\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({ objectIds }),\n                signal: AbortSignal.timeout(10000), // 10 second timeout\n            });\n            \n            if (!response.ok) {\n                logger.error(`Failed to fetch layer data: ${response.statusText}`);\n                return { data: { nodesById: {}, relationsById: {} } };\n            }\n            \n            const layerData = await response.json();\n            return layerData;\n        } catch (error: unknown) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error(`Network error when fetching layer data: ${errorMessage}`);\n            return { data: { nodesById: {}, relationsById: {} } };\n        }\n    }\n\n    /**\n     * Finds a node with exact text match under a parent node\n     * @returns The matching node or undefined\n     */\n    async findNodeByText({\n        parentNodeId,\n        nodeText,\n    }: {\n        parentNodeId: string;\n        nodeText: string;\n    }) {\n        const { parentNode, childNodes } = await this.getChildNodes({\n            parentNodeId,\n        });\n        console.log(\n            \"findNodeByText: searching for exact text match:\",\n            nodeText\n        );\n        console.log(\n            \"findNodeByText: child nodes content:\",\n            childNodes\n                .filter((node) => node)\n                .map((node) => ({\n                    id: node.id,\n                    content: node.content,\n                    textValue: node.content?.[0]?.value,\n                }))\n        );\n\n        const node = childNodes.find(\n            (node) =>\n                node &&\n                node.content &&\n                node.content.length > 0 &&\n                node.content[0].value === nodeText\n        );\n\n        console.log(\"findNodeByText: found node:\", {\n            searchedFor: nodeText,\n            foundNodeContent: node?.content?.[0]?.value,\n            node,\n        });\n\n        return node;\n    }\n\n    async getChildNodes({\n        parentNodeId,\n    }: {\n        parentNodeId: string;\n    }): Promise<{ parentNode: GraphNode; childNodes: GraphNode[] }> {\n        const layerData = await this.getLayerData([parentNodeId]);\n\n        const parentNode = layerData.data.nodesById[parentNodeId];\n\n        const childRelations = Object.values(\n            layerData.data.relationsById\n        ).filter(\n            (relation): relation is Relation =>\n                relation !== null &&\n                typeof relation === \"object\" &&\n                \"fromId\" in relation &&\n                \"toId\" in relation &&\n                \"relationTypeId\" in relation &&\n                relation.fromId === parentNodeId &&\n                relation.relationTypeId === \"child\"\n        );\n\n        const childNodes = childRelations.map((relation) => {\n            const nodeData = layerData.data.nodesById[relation.toId];\n            return nodeData;\n        });\n\n        return {\n            parentNode,\n            childNodes,\n        };\n    }\n\n    getNodeUrl(nodeId: string): string {\n        return `${this.baseUrl}/g/all/global-root-to-users/all/users-to-user-relation-id/${nodeId}`;\n    }\n}\n\nexport const parseNodeIdFromUrl = (url: string): string => {\n    const regex =\n        /^https?:\\/\\/mew-edge\\.ideaflow\\.app\\/g\\/all\\/global-root-to-users\\/all\\/users-to-user-relation-id-[^\\/]+\\/user-root-id-[^\\/]+$/;\n    if (!regex.test(url)) {\n        throw new Error(\"Invalid user node URL format\");\n    }\n    const urlParts = url.split(\"/\");\n    const lastPart = urlParts[urlParts.length - 1];\n\n    // First handle any raw %7C or %7c that might be in the string\n    let decoded = lastPart.replace(/%7C/gi, \"|\");\n    // Then do a full URL decode to handle any other encoded characters\n    decoded = decodeURIComponent(decoded);\n    // Finally ensure any remaining encoded pipes are handled\n    decoded = decoded.replace(/%7C/gi, \"|\");\n\n    return decoded;\n};\n\nexport interface GraphNode {\n    version: number;\n    id: string;\n    authorId: string;\n    createdAt: string;\n    updatedAt: string;\n    content: ContentBlock[];\n    isPublic: boolean;\n    isNewRelatedObjectsPublic: boolean;\n    relationId: string | null;\n    canonicalRelationId: string | null;\n    isChecked: boolean | null;\n}\n\nexport interface ContentBlock {\n    type: \"text\" | \"mention\"; // Could be expanded if there are other types\n    value: string;\n}\n\ninterface User {\n    id: string;\n    username: string;\n    email: string;\n}\n\nexport interface Relation {\n    fromId: string;\n    toId: string;\n    relationTypeId: string;\n}\n\ninterface SyncResponse {\n    data: {\n        usersById: {\n            [key: string]: User;\n        };\n        nodesById: {\n            [key: string]: GraphNode;\n        };\n        relationsById: {\n            [key: string]: Relation;\n        };\n    };\n}\n\ninterface TokenData {\n    access_token: string;\n    expires_in: number;\n    token_type: string;\n}\n", "/* mewClipper.ts - Integrated with the real Mew API */\n// in the future we will want to update this such that it handles login --\n// the user logs in w the same account they use for Mew, and then we\n// automatically grab the url to their user node using some lookup table\n\nimport { MewAPI, parseNodeIdFromUrl } from \"./MewService\";\nimport { Logger } from \"./utils/logger\";\n\nconst logger = new Logger(\"MewClipper\");\n\n// Helper functions for chrome.storage access\nasync function getStorageValue(key: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.get(key, (result) => {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(result[key]);\n            }\n        });\n    });\n}\n\nasync function setStorageValue(key: string, value: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.set({ [key]: value }, () => {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\nexport const mewApi = new MewAPI();\n\n// Add this helper function after setStorageValue\nasync function getUserId(): Promise<string> {\n    const stored = await getStorageValue(\"userNodeId\");\n    if (!stored) {\n        throw new Error(\n            \"User node id not found in storage. Please complete setup properly.\"\n        );\n    }\n    // Decode the stored value\n    let decoded = decodeURIComponent(stored);\n    // Replace any occurrence of '%7C' (case-insensitive) with the pipe character '|'\n    decoded = decoded.replace(/%7C/gi, \"|\");\n    return decoded;\n}\n\n// Define a variable for the node name to allow easy changes\nconst myClipsFolderName = \"My Highlights\";\n\n/* ensureMyClips: Checks whether the \"My Clips\" folder is cached in storage.\n * If not, it retrieves the user node id (saved during setup) and calls MewAPI.addNode\n * to create a node with content \"My Clips\" under the user's node. The new node id is cached and returned.\n */\nexport async function ensureMyClips(): Promise<string> {\n    console.log(\"[MewClipper] Starting search for folder:\", myClipsFolderName);\n\n    // Get user's root URL and extract node ID\n    const userRootUrl = await getStorageValue(\"userRootUrl\");\n    if (!userRootUrl) {\n        console.error(\"[MewClipper] User root URL not found in storage.\");\n        throw new Error(\"User root URL is required for setup\");\n    }\n    console.log(\"[MewClipper] Retrieved user root URL:\", userRootUrl);\n\n    let rootNodeId: string;\n    try {\n        // Validate URL format first\n        const urlObj = new URL(userRootUrl);\n        if (!urlObj.hostname.includes(\"mew-edge.ideaflow.app\")) {\n            throw new Error(\"Invalid URL: Must be from mew-edge.ideaflow.app\");\n        }\n\n        rootNodeId = parseNodeIdFromUrl(userRootUrl);\n        if (!rootNodeId) {\n            throw new Error(\"Failed to extract root node ID from URL\");\n        }\n        console.log(\"[MewClipper] Extracted root node ID:\", rootNodeId);\n    } catch (error) {\n        console.error(\n            \"[MewClipper] Invalid user root URL stored:\",\n            userRootUrl,\n            \"Error:\",\n            error\n        );\n        throw new Error(\n            \"Invalid user root URL format. Please provide a correct user node URL.\"\n        );\n    }\n\n    // Look for existing node folder under root node\n    console.log(\n        `[MewClipper] Searching for folder with exact name '${myClipsFolderName}' under root node '${rootNodeId}'`\n    );\n    const existingNode = await mewApi.findNodeByText({\n        parentNodeId: rootNodeId,\n        nodeText: myClipsFolderName,\n    });\n\n    if (existingNode) {\n        console.log(\n            `[MewClipper] Found existing ${myClipsFolderName} folder with id:`,\n            existingNode.id\n        );\n        return existingNode.id;\n    }\n\n    // Create new node folder if it doesn't exist\n    console.log(\n        `[MewClipper] Creating '${myClipsFolderName}' folder under the root node.`\n    );\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: myClipsFolderName },\n        parentNodeId: rootNodeId,\n        authorId: await getUserId(),\n    });\n\n    const newClipsFolderId = response.newNodeId;\n    console.log(\n        `[MewClipper] '${myClipsFolderName}' folder created with id:`,\n        newClipsFolderId\n    );\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return newClipsFolderId;\n}\n\n/* getArticleNode: Retrieves (and caches) an article node for the given page.\n * If an article node for the given URL exists in storage, it is returned;\n * otherwise, a new article node is created under the My Clips folder with the page title as content.\n * An additional child node storing the URL is added for reference.\n */\nexport async function getArticleNode(\n    title: string,\n    url: string,\n    myClipsFolderId: string\n): Promise<string> {\n    const storageKey = \"articleNodes\";\n    let articleNodes =\n        ((await getStorageValue(storageKey)) as { [key: string]: string }) ||\n        {};\n    if (articleNodes[url]) {\n        console.log(\n            \"[MewClipper] Found potential existing article node for url:\",\n            url\n        );\n        // Verify the node is still a direct child of My Highlights\n        const { childNodes } = await mewApi.getChildNodes({\n            parentNodeId: myClipsFolderId,\n        });\n        const isStillChild = childNodes.some(\n            (node) => node.id === articleNodes[url]\n        );\n        if (isStillChild) {\n            console.log(\n                \"[MewClipper] Verified article node is still a child of My Highlights\"\n            );\n            return articleNodes[url];\n        }\n        console.log(\n            \"[MewClipper] Article node no longer a child of My Highlights, creating new one\"\n        );\n    }\n    console.log(\"[MewClipper] Creating new article node for\", title);\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: title },\n        parentNodeId: myClipsFolderId,\n        authorId: await getUserId(),\n    });\n    const articleNodeId = response.newNodeId;\n    // Create an additional child node to store the URL for reference.\n    await mewApi.addNode({\n        content: { type: \"text\", text: url },\n        parentNodeId: articleNodeId,\n        relationLabel: \"url\",\n        authorId: await getUserId(),\n    });\n    articleNodes[url] = articleNodeId;\n    await setStorageValue(storageKey, articleNodes);\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return articleNodeId;\n}\n\n/* addClip: Adds a clip (text) as a child node under the specified article node using the real Mew API.\n * Returns the created clip's node id.\n */\nexport async function addClip(\n    articleNodeId: string,\n    clipText: string\n): Promise<string> {\n    console.log(\"[MewClipper] Adding clip to article node:\", articleNodeId);\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: clipText },\n        parentNodeId: articleNodeId,\n        authorId: await getUserId(),\n    });\n    console.log(\"[MewClipper] Created clip node with id:\", response.newNodeId);\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return response.newNodeId;\n}\n", "/* YouTubeService.ts - Service for handling YouTube video transcripts */\n\n/**\n * YouTube Service for extracting transcripts from YouTube videos.\n * Uses direct API calls to extract transcripts without relying on DOM scraping.\n */\nexport class YouTubeService {\n    // Debug flag to enable verbose logging\n    private static readonly DEBUG = true;\n    private apiKey = \"\";\n\n    /**\n     * Logs debugging information when DEBUG is enabled\n     */\n    private static debugLog(message: string, data?: any): void {\n        if (YouTubeService.DEBUG) {\n            console.log(`[YouTubeService Debug] ${message}`, data || \"\");\n        }\n    }\n\n    /**\n     * Logs error information\n     */\n    private static errorLog(message: string, error?: any): void {\n        console.error(`[YouTubeService Error] ${message}`, error || \"\");\n    }\n\n    /**\n     * Logs general information\n     */\n    private static infoLog(message: string, data?: any): void {\n        console.info(`[YouTubeService Info] ${message}`, data || \"\");\n    }\n\n    async setApiKey(key: string): Promise<void> {\n        this.apiKey = key;\n        await chrome.storage.local.set({ youtubeApiKey: key });\n        YouTubeService.infoLog(\"YouTube API key saved\");\n    }\n\n    async getApiKey(): Promise<string> {\n        if (this.apiKey) {\n            return this.apiKey;\n        }\n\n        const result = await chrome.storage.local.get(\"youtubeApiKey\");\n        this.apiKey = result.youtubeApiKey || \"\";\n        return this.apiKey;\n    }\n\n    /**\n     * Extracts video ID from a YouTube URL\n     * Supports formats:\n     * - youtube.com/watch?v=VIDEO_ID\n     * - youtu.be/VIDEO_ID\n     * - youtube.com/v/VIDEO_ID\n     * - youtube.com/embed/VIDEO_ID\n     */\n    static extractVideoId(url: string): string | null {\n        if (!url) return null;\n\n        // Handle youtu.be short links\n        const shortMatch = url.match(/youtu\\.be\\/([a-zA-Z0-9_-]{11})/);\n        if (shortMatch) return shortMatch[1];\n\n        // Handle standard youtube.com links\n        let videoIdMatch = url.match(/[?&]v=([a-zA-Z0-9_-]{11})/);\n        if (videoIdMatch) return videoIdMatch[1];\n\n        // Handle /embed/ format\n        videoIdMatch = url.match(/embed\\/([a-zA-Z0-9_-]{11})/);\n        if (videoIdMatch) return videoIdMatch[1];\n\n        // Handle /v/ format\n        videoIdMatch = url.match(/\\/v\\/([a-zA-Z0-9_-]{11})/);\n        if (videoIdMatch) return videoIdMatch[1];\n\n        return null;\n    }\n\n    /**\n     * Checks if a given URL is a YouTube video\n     */\n    static isYouTubeVideo(url: string): boolean {\n        return (\n            !!url &&\n            (url.includes(\"youtube.com/watch\") ||\n                url.includes(\"youtu.be/\") ||\n                url.includes(\"youtube.com/embed\") ||\n                url.includes(\"youtube.com/v/\"))\n        );\n    }\n\n    /**\n     * Main method to fetch transcript for a YouTube video.\n     * Uses a direct API approach that's more reliable than DOM scraping.\n     */\n    async getTranscript(videoId: string): Promise<string> {\n        try {\n            YouTubeService.infoLog(`Getting transcript for video ${videoId}`);\n\n            // Try direct fetch methods first\n            try {\n                const transcript = await this.fetchDirectTranscript(videoId);\n                if (transcript) {\n                    return transcript;\n                }\n            } catch (error) {\n                YouTubeService.errorLog(\n                    \"Direct transcript fetch failed\",\n                    error\n                );\n            }\n\n            // If direct methods fail, return empty string\n            return \"\";\n        } catch (error) {\n            YouTubeService.errorLog(\"Error getting transcript\", error);\n            return \"\";\n        }\n    }\n\n    /**\n     * Fetches transcript by calling YouTube's timedtext API directly.\n     * This method avoids DOM scraping completely for better reliability.\n     */\n    private async fetchDirectTranscript(videoId: string): Promise<string> {\n        console.log(\"[TRANSCRIPT DEBUG] Starting direct API transcript fetch\");\n\n        // Try YouTube API captions endpoint\n        const captionUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en`;\n\n        try {\n            const response = await fetch(captionUrl);\n            if (response.ok) {\n                const text = await response.text();\n                if (text && text.includes(\"<text\")) {\n                    return this.parseXmlTranscript(text);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching transcript:\", error);\n        }\n\n        // If we can't get the transcript, throw an error\n        throw new Error(\"Could not fetch transcript\");\n    }\n\n    /**\n     * Parse transcript in XML format\n     */\n    private parseXmlTranscript(xmlContent: string): string {\n        let transcript = \"\";\n\n        // Very basic XML parsing - would be better with a proper XML parser\n        const textTags = xmlContent.match(/<text[^>]*>(.*?)<\\/text>/g) || [];\n\n        for (const tag of textTags) {\n            // Extract content and timing\n            const contentMatch = tag.match(/<text[^>]*>(.*?)<\\/text>/);\n            const startMatch = tag.match(/start=\"([^\"]*)\"/);\n\n            if (contentMatch && startMatch) {\n                const content = this.decodeHtmlEntities(contentMatch[1]);\n                const startTime = parseFloat(startMatch[1]);\n\n                // Format timestamp\n                const minutes = Math.floor(startTime / 60);\n                const seconds = Math.floor(startTime % 60);\n                const timestamp = `[${minutes}:${seconds\n                    .toString()\n                    .padStart(2, \"0\")}]`;\n\n                transcript += `${timestamp} ${content}\\n`;\n            }\n        }\n\n        return transcript;\n    }\n\n    /**\n     * Helper to decode HTML entities in transcript text\n     */\n    private decodeHtmlEntities(text: string): string {\n        const textarea = document.createElement(\"textarea\");\n        textarea.innerHTML = text;\n        return textarea.value;\n    }\n}\n", "/* background.ts - Background script for Mew Web Clipper extension */\n\nimport { ensureMyClips, getArticleNode, addClip } from \"./mewClipper\";\nimport { mewApi } from \"./mewClipper\";\nimport { YouTubeService } from \"./services/YouTubeService\";\n\n// Global error handler for the service worker\nself.addEventListener(\"error\", (event) => {\n    console.error(\"[ServiceWorker] Uncaught error:\", event.error);\n});\n\n// Global unhandled promise rejection handler\nself.addEventListener(\"unhandledrejection\", (event) => {\n    console.error(\"[ServiceWorker] Unhandled promise rejection:\", event.reason);\n});\n\nconst youtubeService = new YouTubeService();\n\n// Function to inject notification system into a tab\nasync function injectNotificationSystem(tabId: number) {\n    // Inject CSS\n    await chrome.scripting.insertCSS({\n        target: { tabId },\n        files: [\"notification.css\"],\n    });\n\n    // Inject notification script\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        files: [\"notification.js\"],\n    });\n}\n\n// Function to show notification in a tab\nasync function showNotification(tabId: number, message: string) {\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        func: (msg) => {\n            // Get the showNotification function from the injected script\n            const showNotification = (window as any).showNotification;\n            if (showNotification) {\n                showNotification(msg);\n            }\n        },\n        args: [message],\n    });\n}\n\nconsole.log(\"[Background] Mew Web Clipper extension background initialized.\");\n\n// Clear storage command for development/testing\nchrome.runtime.onInstalled.addListener(async () => {\n    console.log(\n        \"[Background] onInstalled event fired. Creating context menu items.\"\n    );\n    chrome.contextMenus.create({\n        id: \"clearStorage\",\n        title: \"Clear Mew Storage (Debug)\",\n        contexts: [\"page\"],\n    });\n    chrome.contextMenus.create({\n        id: \"saveSelection\",\n        title: \"Save Selection to Mew\",\n        contexts: [\"selection\"],\n    });\n    chrome.contextMenus.create({\n        id: \"savePage\",\n        title: \"Save Page to Mew\",\n        contexts: [\"page\"],\n    });\n\n    // Add YouTube API key configuration menu item\n    chrome.contextMenus.create({\n        id: \"setYouTubeApiKey\",\n        title: \"Set YouTube API Key\",\n        contexts: [\"page\"],\n    });\n\n    // Check if both user node id and root url have been properly set\n    const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n        \"userNodeId\",\n        \"userRootUrl\",\n    ]);\n    if (\n        !userNodeId ||\n        !userRootUrl ||\n        !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n    ) {\n        console.log(\n            \"[Background] Missing or invalid user configuration. Opening setup window.\"\n        );\n        // Clear any potentially invalid stored values\n        await chrome.storage.local.remove([\"userNodeId\", \"userRootUrl\"]);\n        chrome.windows.create({\n            url: \"setup.html\",\n            type: \"normal\",\n            width: 600,\n            height: 400,\n        });\n    } else {\n        console.log(\"[Background] User configuration verified:\", {\n            userNodeId,\n            userRootUrl,\n        });\n    }\n});\n\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n    console.log(\"[Background] Context menu clicked. Info:\", info);\n    if (!tab || !tab.id) {\n        console.error(\"[Background] No tab information available.\");\n        return;\n    }\n\n    try {\n        // Check if we have valid configuration before proceeding\n        const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n            \"userNodeId\",\n            \"userRootUrl\",\n        ]);\n        if (\n            !userNodeId ||\n            !userRootUrl ||\n            !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n        ) {\n            throw new Error(\"Please complete the Mew Web Clipper setup first\");\n        }\n\n        if (info.menuItemId === \"clearStorage\") {\n            await chrome.storage.local.clear();\n            console.log(\"[Background] Cleared local storage\");\n            return;\n        }\n\n        if (info.menuItemId === \"setYouTubeApiKey\") {\n            // Prompt user for YouTube API key\n            if (tab.id) {\n                await injectNotificationSystem(tab.id);\n                const result = await chrome.scripting.executeScript({\n                    target: { tabId: tab.id },\n                    func: () => {\n                        return prompt(\"Enter your YouTube Data API key:\");\n                    },\n                });\n\n                if (result && result[0] && result[0].result) {\n                    const apiKey = result[0].result;\n                    try {\n                        await youtubeService.setApiKey(apiKey);\n                        await showNotification(\n                            tab.id,\n                            \"YouTube API key saved successfully\"\n                        );\n                        console.log(\"[Background] YouTube API key saved\");\n                    } catch (error) {\n                        console.error(\n                            \"[Background] Error saving YouTube API key:\",\n                            error\n                        );\n                        await showNotification(\n                            tab.id,\n                            \"Error saving YouTube API key\"\n                        );\n                    }\n                } else {\n                    console.log(\n                        \"[Background] API key setting cancelled by user\"\n                    );\n                    await showNotification(tab.id, \"API key setting cancelled\");\n                }\n            }\n            return;\n        }\n\n        // Optimistic UI: Show notification immediately\n        if (tab.id) {\n            await injectNotificationSystem(tab.id);\n            await showNotification(tab.id, \"Saving to My Highlights...\");\n        }\n\n        const myClipsFolderId = await ensureMyClips();\n        console.log(\"[Mew API] ensureMyClips response:\", myClipsFolderId);\n\n        if (!tab.title || !tab.url) {\n            console.error(\"[Background] Tab missing title or url.\");\n            return;\n        }\n\n        const articleNodeId = await getArticleNode(\n            tab.title,\n            tab.url,\n            myClipsFolderId\n        );\n        console.log(\"[Mew API] getArticleNode response:\", articleNodeId);\n\n        // Handle YouTube video transcript\n        if (YouTubeService.isYouTubeVideo(tab.url)) {\n            try {\n                const videoId = YouTubeService.extractVideoId(tab.url);\n                if (!videoId) {\n                    throw new Error(\"Failed to extract video ID\");\n                }\n\n                // Check if Transcript node already exists\n                const existingTranscript = await mewApi.findNodeByText({\n                    parentNodeId: articleNodeId,\n                    nodeText: \"Transcript\",\n                });\n\n                // Only create a Transcript node if we can successfully fetch a transcript\n                if (!existingTranscript) {\n                    console.log(\"[Background] Fetching YouTube transcript\");\n\n                    try {\n                        // First try to get transcript with our multi-approach service\n                        let transcript = await youtubeService.getTranscript(\n                            videoId\n                        );\n\n                        // Check if the result is a caption URL that needs to be fetched\n                        if (transcript.startsWith(\"CAPTION_URL:\")) {\n                            console.log(\n                                \"[Background] Received caption URL from page scraping\"\n                            );\n                            const captionUrl = transcript.substring(\n                                \"CAPTION_URL:\".length\n                            );\n\n                            try {\n                                // Fetch the caption URL\n                                const response = await fetch(captionUrl);\n                                if (response.ok) {\n                                    const captionText = await response.text();\n\n                                    // Parse the XML caption data\n                                    if (captionText.includes(\"<text \")) {\n                                        // Simple XML parsing to extract captions\n                                        const parser = new DOMParser();\n                                        const xmlDoc = parser.parseFromString(\n                                            captionText,\n                                            \"text/xml\"\n                                        );\n                                        const textElements =\n                                            xmlDoc.getElementsByTagName(\"text\");\n\n                                        let parsedTranscript = \"\";\n                                        for (\n                                            let i = 0;\n                                            i < textElements.length;\n                                            i++\n                                        ) {\n                                            const element = textElements[i];\n                                            const text =\n                                                element.textContent || \"\";\n                                            const start =\n                                                element.getAttribute(\"start\");\n\n                                            if (text.trim() && start) {\n                                                const seconds =\n                                                    parseFloat(start);\n                                                const minutes = Math.floor(\n                                                    seconds / 60\n                                                );\n                                                const remainingSeconds =\n                                                    Math.floor(seconds % 60);\n                                                const timestamp = `[${minutes\n                                                    .toString()\n                                                    .padStart(\n                                                        2,\n                                                        \"0\"\n                                                    )}:${remainingSeconds\n                                                    .toString()\n                                                    .padStart(2, \"0\")}]`;\n\n                                                parsedTranscript += `${timestamp} ${text.trim()}\\n`;\n                                            }\n                                        }\n\n                                        if (parsedTranscript.trim()) {\n                                            transcript =\n                                                parsedTranscript.trim();\n                                            console.log(\n                                                \"[Background] Successfully parsed caption URL data\"\n                                            );\n                                        }\n                                    }\n                                }\n                            } catch (captionError) {\n                                console.error(\n                                    \"[Background] Error fetching caption URL:\",\n                                    captionError\n                                );\n                            }\n                        }\n\n                        // Only create the Transcript node if we have a valid transcript\n                        if (transcript && transcript.trim()) {\n                            // Create Transcript node\n                            const transcriptNodeId = await addClip(\n                                articleNodeId,\n                                \"Transcript\"\n                            );\n                            console.log(\n                                \"[Background] Created Transcript node:\",\n                                transcriptNodeId\n                            );\n\n                            // Add transcript text as child of Transcript node\n                            const transcriptTextNodeId = await addClip(\n                                transcriptNodeId,\n                                transcript\n                            );\n                            console.log(\n                                \"[Background] Added transcript text node:\",\n                                transcriptTextNodeId\n                            );\n\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    \"Saved page with transcript to My Highlights\"\n                                );\n                            }\n                        } else {\n                            console.log(\n                                \"[Background] No valid transcript found, not creating Transcript node\"\n                            );\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    \"Saved page to My Highlights\"\n                                );\n                            }\n                        }\n                    } catch (transcriptError) {\n                        console.error(\n                            \"[Background] All transcript fetching approaches failed:\",\n                            transcriptError\n                        );\n\n                        // Show a detailed error message so we can debug the issue\n                        const errorMessage =\n                            transcriptError instanceof Error\n                                ? transcriptError.message\n                                : String(transcriptError);\n\n                        console.error(\n                            \"[Background] Transcript error details:\",\n                            errorMessage\n                        );\n\n                        // Create a transcript node with the error information for debugging\n                        try {\n                            const transcriptNodeId = await addClip(\n                                articleNodeId,\n                                \"Transcript (Error Details)\"\n                            );\n\n                            await addClip(\n                                transcriptNodeId,\n                                `Transcript extraction failed with error: ${errorMessage}\\n\\nThis is a debug node to help diagnose the issue.`\n                            );\n\n                            console.log(\n                                \"[Background] Created transcript error debug node:\",\n                                transcriptNodeId\n                            );\n                        } catch (debugNodeError) {\n                            console.error(\n                                \"[Background] Failed to create debug node:\",\n                                debugNodeError\n                            );\n                        }\n\n                        // Don't create a real transcript node since extraction failed\n                        if (tab.id) {\n                            await showNotification(\n                                tab.id,\n                                `Saved page to My Highlights (transcript error: ${errorMessage.substring(\n                                    0,\n                                    50\n                                )}${errorMessage.length > 50 ? \"...\" : \"\"})`\n                            );\n                        }\n                    }\n                } else {\n                    console.log(\n                        \"[Background] Transcript node already exists, skipping transcript fetch\"\n                    );\n\n                    if (tab.id) {\n                        await showNotification(\n                            tab.id,\n                            \"Saved page to My Highlights\"\n                        );\n                    }\n                }\n            } catch (error) {\n                console.error(\n                    \"[Background] Error processing YouTube page:\",\n                    error\n                );\n                // Continue with normal page save even if transcript fails\n                if (tab.id) {\n                    await showNotification(\n                        tab.id,\n                        \"Saved page to My Highlights (transcript unavailable)\"\n                    );\n                }\n            }\n        }\n\n        if (info.menuItemId === \"saveSelection\" && info.selectionText) {\n            console.log(\"[Background] Saving selection clip.\");\n            const clipNodeId = await addClip(articleNodeId, info.selectionText);\n            console.log(\"[Mew API] addClip response:\", clipNodeId);\n            console.log(\"[Background] Clip saved with node id:\", clipNodeId);\n            if (tab.id) {\n                await showNotification(\n                    tab.id,\n                    \"Selection saved to My Highlights\"\n                );\n            }\n        } else if (info.menuItemId === \"savePage\") {\n            console.log(\"[Background] Saving full page capture.\");\n            // For full page capture we simply ensure the article node exists\n            console.log(\n                \"[Background] Page saved. Article node id:\",\n                articleNodeId\n            );\n            if (tab.id) {\n                await showNotification(tab.id, \"Page saved to My Highlights\");\n            }\n        }\n    } catch (err) {\n        console.error(\"[Background] Error processing context menu click:\", err);\n        if (tab && tab.id) {\n            await showNotification(tab.id, \"Error saving to My Highlights\");\n        }\n    }\n});\n\nchrome.commands.onCommand.addListener(async (command) => {\n    console.log(\"[Background] Command received:\", command);\n    if (command === \"clipPage\") {\n        try {\n            const tabs = await chrome.tabs.query({\n                active: true,\n                currentWindow: true,\n            });\n            if (!tabs || tabs.length === 0) {\n                console.error(\"[Background] No active tab found.\");\n                return;\n            }\n            const tab = tabs[0];\n            if (!tab.title || !tab.url) {\n                console.error(\"[Background] Active tab missing title or url.\");\n                return;\n            }\n\n            // Check if we have valid configuration before proceeding\n            const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n                \"userNodeId\",\n                \"userRootUrl\",\n            ]);\n            if (\n                !userNodeId ||\n                !userRootUrl ||\n                !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n            ) {\n                throw new Error(\n                    \"Please complete the Mew Web Clipper setup first\"\n                );\n            }\n\n            // Optimistic UI: Show notification immediately\n            if (tab.id) {\n                await injectNotificationSystem(tab.id);\n                await showNotification(\n                    tab.id,\n                    \"Saving page to My Highlights...\"\n                );\n            }\n\n            const myClipsFolderId = await ensureMyClips();\n            console.log(\"[Mew API] ensureMyClips response:\", myClipsFolderId);\n            const articleNodeId = await getArticleNode(\n                tab.title,\n                tab.url,\n                myClipsFolderId\n            );\n            console.log(\"[Mew API] getArticleNode response:\", articleNodeId);\n\n            // Handle YouTube video transcript\n            if (YouTubeService.isYouTubeVideo(tab.url)) {\n                try {\n                    const videoId = YouTubeService.extractVideoId(tab.url);\n                    if (!videoId) {\n                        throw new Error(\"Failed to extract video ID\");\n                    }\n\n                    // Check if Transcript node already exists\n                    console.log(\n                        \"[TRANSCRIPT DEBUG] Checking if Transcript node already exists under article node:\",\n                        articleNodeId\n                    );\n                    const existingTranscript = await mewApi.findNodeByText({\n                        parentNodeId: articleNodeId,\n                        nodeText: \"Transcript\",\n                    });\n                    console.log(\n                        \"[TRANSCRIPT DEBUG] Existing transcript node check result:\",\n                        existingTranscript\n                    );\n\n                    // Only create a Transcript node if we can successfully fetch a transcript\n                    if (!existingTranscript) {\n                        console.log(\"[Background] Fetching YouTube transcript\");\n                        console.log(\n                            \"[TRANSCRIPT DEBUG] No existing transcript node found, will attempt to create one\"\n                        );\n\n                        try {\n                            // First try to get transcript with our multi-approach service\n                            let transcript = await youtubeService.getTranscript(\n                                videoId\n                            );\n\n                            // Check if the result is a caption URL that needs to be fetched\n                            if (transcript.startsWith(\"CAPTION_URL:\")) {\n                                console.log(\n                                    \"[Background] Received caption URL from page scraping\"\n                                );\n                                const captionUrl = transcript.substring(\n                                    \"CAPTION_URL:\".length\n                                );\n\n                                try {\n                                    // Fetch the caption URL\n                                    const response = await fetch(captionUrl);\n                                    if (response.ok) {\n                                        const captionText =\n                                            await response.text();\n\n                                        // Parse the XML caption data\n                                        if (captionText.includes(\"<text \")) {\n                                            // Simple XML parsing to extract captions\n                                            const parser = new DOMParser();\n                                            const xmlDoc =\n                                                parser.parseFromString(\n                                                    captionText,\n                                                    \"text/xml\"\n                                                );\n                                            const textElements =\n                                                xmlDoc.getElementsByTagName(\n                                                    \"text\"\n                                                );\n\n                                            let parsedTranscript = \"\";\n                                            for (\n                                                let i = 0;\n                                                i < textElements.length;\n                                                i++\n                                            ) {\n                                                const element = textElements[i];\n                                                const text =\n                                                    element.textContent || \"\";\n                                                const start =\n                                                    element.getAttribute(\n                                                        \"start\"\n                                                    );\n\n                                                if (text.trim() && start) {\n                                                    const seconds =\n                                                        parseFloat(start);\n                                                    const minutes = Math.floor(\n                                                        seconds / 60\n                                                    );\n                                                    const remainingSeconds =\n                                                        Math.floor(\n                                                            seconds % 60\n                                                        );\n                                                    const timestamp = `[${minutes\n                                                        .toString()\n                                                        .padStart(\n                                                            2,\n                                                            \"0\"\n                                                        )}:${remainingSeconds\n                                                        .toString()\n                                                        .padStart(2, \"0\")}]`;\n\n                                                    parsedTranscript += `${timestamp} ${text.trim()}\\n`;\n                                                }\n                                            }\n\n                                            if (parsedTranscript.trim()) {\n                                                transcript =\n                                                    parsedTranscript.trim();\n                                                console.log(\n                                                    \"[Background] Successfully parsed caption URL data\"\n                                                );\n                                            }\n                                        }\n                                    }\n                                } catch (captionError) {\n                                    console.error(\n                                        \"[Background] Error fetching caption URL:\",\n                                        captionError\n                                    );\n                                }\n                            }\n\n                            // Only create the Transcript node if we have a valid transcript\n                            if (transcript && transcript.trim()) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Valid transcript received, creating nodes\"\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript length:\",\n                                    transcript.length,\n                                    \"chars\"\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript preview:\",\n                                    transcript.substring(0, 100) + \"...\"\n                                );\n\n                                // Create Transcript node\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Creating parent Transcript node under article:\",\n                                    articleNodeId\n                                );\n                                const transcriptNodeId = await addClip(\n                                    articleNodeId,\n                                    \"Transcript\"\n                                );\n                                console.log(\n                                    \"[Background] Created Transcript node:\",\n                                    transcriptNodeId\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Parent Transcript node created successfully\"\n                                );\n\n                                // Add transcript text as child of Transcript node\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Adding transcript text as child of Transcript node:\",\n                                    transcriptNodeId\n                                );\n                                const transcriptTextNodeId = await addClip(\n                                    transcriptNodeId,\n                                    transcript\n                                );\n                                console.log(\n                                    \"[Background] Added transcript text node:\",\n                                    transcriptTextNodeId\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript text node created successfully with ID:\",\n                                    transcriptTextNodeId\n                                );\n\n                                if (tab.id) {\n                                    await showNotification(\n                                        tab.id,\n                                        \"Saved page with transcript to My Highlights\"\n                                    );\n                                }\n                            } else {\n                                console.log(\n                                    \"[Background] No valid transcript found, not creating Transcript node\"\n                                );\n                                if (tab.id) {\n                                    await showNotification(\n                                        tab.id,\n                                        \"Saved page to My Highlights\"\n                                    );\n                                }\n                            }\n                        } catch (transcriptError) {\n                            console.error(\n                                \"[Background] All transcript fetching approaches failed:\",\n                                transcriptError\n                            );\n\n                            // Show a detailed error message so we can debug the issue\n                            const errorMessage =\n                                transcriptError instanceof Error\n                                    ? transcriptError.message\n                                    : String(transcriptError);\n\n                            console.error(\n                                \"[Background] Transcript error details:\",\n                                errorMessage\n                            );\n\n                            // Create a transcript node with the error information for debugging\n                            try {\n                                const transcriptNodeId = await addClip(\n                                    articleNodeId,\n                                    \"Transcript (Error Details)\"\n                                );\n\n                                await addClip(\n                                    transcriptNodeId,\n                                    `Transcript extraction failed with error: ${errorMessage}\\n\\nThis is a debug node to help diagnose the issue.`\n                                );\n\n                                console.log(\n                                    \"[Background] Created transcript error debug node:\",\n                                    transcriptNodeId\n                                );\n                            } catch (debugNodeError) {\n                                console.error(\n                                    \"[Background] Failed to create debug node:\",\n                                    debugNodeError\n                                );\n                            }\n\n                            // Don't create a real transcript node since extraction failed\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    `Saved page to My Highlights (transcript error: ${errorMessage.substring(\n                                        0,\n                                        50\n                                    )}${errorMessage.length > 50 ? \"...\" : \"\"})`\n                                );\n                            }\n                        }\n                    } else {\n                        console.log(\n                            \"[Background] Transcript node already exists, skipping transcript fetch\"\n                        );\n                        if (tab.id) {\n                            await showNotification(\n                                tab.id,\n                                \"Page saved to My Highlights\"\n                            );\n                        }\n                    }\n                } catch (error) {\n                    console.error(\n                        \"[Background] Error processing YouTube transcript:\",\n                        error\n                    );\n                    // Continue with normal page save even if transcript fails\n                    if (tab.id) {\n                        await showNotification(\n                            tab.id,\n                            \"Saved page to My Highlights (transcript unavailable)\"\n                        );\n                    }\n                }\n            } else {\n                console.log(\n                    \"[Background] Page captured via keyboard shortcut. Article node id:\",\n                    articleNodeId\n                );\n                if (tab.id) {\n                    await showNotification(\n                        tab.id,\n                        \"Page saved to My Highlights\"\n                    );\n                }\n            }\n        } catch (err) {\n            console.error(\n                \"[Background] Error processing clipPage command:\",\n                err\n            );\n            const tabs = await chrome.tabs.query({\n                active: true,\n                currentWindow: true,\n            });\n            if (tabs && tabs[0] && tabs[0].id) {\n                await showNotification(\n                    tabs[0].id,\n                    \"Error saving page to My Highlights\"\n                );\n            }\n        }\n    }\n});\n\n// Export the functionality\nexport { injectNotificationSystem, showNotification };\n"],
  "mappings": "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",
  "names": ["node", "logger", "showNotification"]
}
