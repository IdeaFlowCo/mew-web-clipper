{
  "version": 3,
  "sources": ["../utils/logger.ts", "../MewService.ts", "../mewClipper.ts", "../services/YouTubeService.ts", "../background.ts"],
  "sourcesContent": ["export class Logger {\n    private context: string;\n    constructor(context: string) {\n        this.context = context;\n    }\n    info(...args: unknown[]): void {\n        console.log(`[INFO] [${this.context}]`, ...args);\n    }\n    error(...args: unknown[]): void {\n        console.error(`[ERROR] [${this.context}]`, ...args);\n    }\n}\n", "import { Logger } from \"./utils/logger.js\";\n\nexport const AUTH_CONFIG = {\n    baseUrl: \"https://mew-edge.ideaflow.app/api\",\n    baseNodeUrl: \"https://mew-edge.ideaflow.app/\",\n    auth0Domain: \"ideaflow-mew-dev.us.auth0.com\",\n    auth0ClientId: \"zbhouY8SmHtIIJSjt1gu8TR3FgMsgo3J\",\n    auth0ClientSecret:\n        \"x0SAiFCCMwfgNEzU29KFh3TR4sTWuQVDqrRwBWCe0KsbA7WEd-1Ypatb47LCQ_Xb\",\n    auth0Audience: \"https://ideaflow-mew-dev.us.auth0.com/api/v2/\",\n    // userId: \"auth0|6793c6489ed96468672bae93\",\n    // userId: \"auth0|67b00414a18956f5273397da\", // cody+mewagent@ideaflow.io\n};\n\nconst logger = new Logger(\"MewService\");\n\n/* MewService.ts - Tailored for our conversation integration project */\n\nexport interface ConversationNode {\n    id: string;\n    parentNodeId: string;\n    text: string;\n    createdAt: string;\n}\n\nexport enum NodeContentType {\n    Text = \"text\",\n    Replacement = \"replacement\",\n    Mention = \"mention\",\n}\n\nexport interface ReplacementNodeData {\n    referenceNodeId: string;\n    referenceCanonicalRelationId: string;\n}\n\nexport interface MentionData {\n    preMentionText: string;\n    postMentionText: string;\n    mentionNodeId: string;\n}\n\nexport type NodeContent =\n    | { type: NodeContentType.Text; text: string }\n    | {\n          type: NodeContentType.Replacement;\n          replacementNodeData: ReplacementNodeData;\n      }\n    | { type: NodeContentType.Mention; mentionData: MentionData };\n\nexport function createNodeContent(content: any) {\n    // If content is already in the correct format, return it\n    if (Array.isArray(content)) {\n        return content;\n    }\n\n    // Handle our NodeContent type\n    if (content.type === NodeContentType.Text) {\n        return [{ type: \"text\", value: content.text, styles: 0 }];\n    } else if (content.type === \"text\" && content.text) {\n        // Handle the format coming from mewClipper\n        return [{ type: \"text\", value: content.text, styles: 0 }];\n    } else if (content.type === NodeContentType.Mention) {\n        return [\n            {\n                type: \"text\",\n                value: content.mentionData.preMentionText,\n                styles: 0,\n            },\n            {\n                type: \"mention\",\n                value: content.mentionData.mentionNodeId,\n                mentionTrigger: \"@\",\n            },\n            {\n                type: \"text\",\n                value: content.mentionData.postMentionText,\n                styles: 0,\n            },\n        ];\n    } else if (content.type === NodeContentType.Replacement) {\n        return [{ type: \"text\", value: \"replacement\", styles: 0 }];\n    }\n\n    // Default case\n    return [{ type: \"text\", value: \"\", styles: 0 }];\n}\n\nexport class MewAPI {\n    private baseUrl: string;\n    private baseNodeUrl: string;\n    private token: string;\n    private currentUserId: string;\n\n    constructor() {\n        // Use the base URL from our AUTH_CONFIG\n        this.baseUrl = AUTH_CONFIG.baseUrl;\n        this.baseNodeUrl = AUTH_CONFIG.baseNodeUrl;\n        this.token = \"\";\n        this.currentUserId = \"\"; // Will be set from user's root node URL\n    }\n\n    public setCurrentUserId(userId: string): void {\n        this.currentUserId = userId;\n    }\n\n    public getCurrentUser(): { id: string } {\n        return { id: this.currentUserId };\n    }\n\n    private uuid(): string {\n        return crypto.randomUUID();\n    }\n\n    async getAccessToken(): Promise<string> {\n        // Retrieve an access token using Auth0 credentials.\n        try {\n            const response = await fetch(\n                `https://${AUTH_CONFIG.auth0Domain}/oauth/token`,\n                {\n                    method: \"POST\",\n                    mode: \"cors\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({\n                        client_id: AUTH_CONFIG.auth0ClientId,\n                        client_secret: AUTH_CONFIG.auth0ClientSecret,\n                        audience: AUTH_CONFIG.auth0Audience,\n                        grant_type: \"client_credentials\",\n                    }),\n                }\n            );\n\n            if (!response.ok) {\n                throw new Error(`Auth failed: ${response.statusText}`);\n            }\n\n            const data = await response.json();\n            this.token = data.access_token;\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                logger.error(\"Failed to fetch access token:\", error);\n            } else {\n                logger.error(\"Failed to fetch access token: Unknown error\");\n            }\n            // Fallback to a dummy token if necessary\n            this.token = \"dummy-access-token\";\n        }\n        return this.token;\n    }\n\n    async addNode(input: {\n        content: any;\n        parentNodeId?: string;\n        relationLabel?: string;\n        isChecked?: boolean;\n        authorId?: string;\n    }): Promise<{\n        newNodeId: string;\n        newRelationLabelNodeId: string;\n        parentChildRelationId: string;\n        referenceNodeId: string;\n        referenceCanonicalRelationId: string;\n        isChecked?: boolean;\n    }> {\n        const { content, parentNodeId, relationLabel, isChecked, authorId } =\n            input;\n        const nodeContent = createNodeContent(content);\n        const usedAuthorId = authorId ?? this.currentUserId;\n        const newNodeId = this.uuid();\n        const parentChildRelationId = this.uuid();\n        const transactionId = this.uuid();\n        const timestamp = Date.now();\n        let relationLabelNodeId = \"\";\n\n        const updates: any[] = [];\n\n        // Step 1: Add the new node.\n        updates.push({\n            operation: \"addNode\",\n            node: {\n                version: 1,\n                id: newNodeId,\n                authorId: usedAuthorId,\n                createdAt: timestamp,\n                updatedAt: timestamp,\n                content: nodeContent,\n                isPublic: true,\n                isNewRelatedObjectsPublic: false,\n                canonicalRelationId: parentNodeId\n                    ? parentChildRelationId\n                    : null,\n                isChecked: isChecked ?? null,\n            },\n        });\n\n        // Step 2: If a parent is provided, establish the child relation.\n        if (parentNodeId) {\n            updates.push({\n                operation: \"addRelation\",\n                relation: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                fromPos: { int: timestamp, frac: \"a0\" },\n                toPos: { int: timestamp, frac: \"a0\" },\n            });\n            // Single updateRelationList operation for the parent-child relation\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: parentChildRelationId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentNodeId,\n                relatedNodeId: newNodeId,\n            });\n        }\n\n        // Step 3: Optionally create a relation label node if a relationLabel is provided.\n        if (relationLabel) {\n            relationLabelNodeId = this.uuid();\n            updates.push({\n                operation: \"addNode\",\n                node: {\n                    version: 1,\n                    id: relationLabelNodeId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    content: [\n                        { type: \"text\", value: relationLabel, styles: 0 },\n                    ],\n                    isPublic: true,\n                    isNewRelatedObjectsPublic: false,\n                    canonicalRelationId: null,\n                    isChecked: null,\n                },\n            });\n            const newRelationTypeId = this.uuid();\n            updates.push({\n                operation: \"addRelation\",\n                relation: {\n                    version: 1,\n                    id: newRelationTypeId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentChildRelationId,\n                    toId: relationLabelNodeId,\n                    relationTypeId: \"__type__\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                fromPos: { int: timestamp, frac: \"a0\" },\n                toPos: { int: timestamp, frac: \"a0\" },\n            });\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: newRelationTypeId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentChildRelationId,\n                relatedNodeId: relationLabelNodeId,\n            });\n            // Update the original child relation to reference the new relation type\n            updates.push({\n                operation: \"updateRelation\",\n                oldProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                newProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: newRelationTypeId,\n                },\n            });\n        }\n\n        // Step 4: If the content type is Replacement, update the parent-child relation accordingly.\n        if (content?.type === \"Replacement\" && content.replacementNodeData) {\n            updates.push({\n                operation: \"updateRelation\",\n                oldProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: newNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId: null,\n                },\n                newProps: {\n                    version: 1,\n                    id: parentChildRelationId,\n                    authorId: usedAuthorId,\n                    createdAt: timestamp,\n                    updatedAt: timestamp,\n                    fromId: parentNodeId,\n                    toId: content.replacementNodeData.referenceNodeId,\n                    relationTypeId: \"child\",\n                    isPublic: true,\n                    canonicalRelationId:\n                        content.replacementNodeData\n                            .referenceCanonicalRelationId,\n                },\n            });\n            updates.push({\n                operation: \"updateRelationList\",\n                relationId: parentChildRelationId,\n                oldPosition: null,\n                newPosition: { int: timestamp, frac: \"a0\" },\n                authorId: usedAuthorId,\n                type: \"all\",\n                oldIsPublic: true,\n                newIsPublic: true,\n                nodeId: parentNodeId,\n                relatedNodeId: content.replacementNodeData.referenceNodeId,\n            });\n        }\n\n        // Step 5: Execute one transaction with all updates.\n        const token = await this.getAccessToken();\n        const payload = {\n            clientId: AUTH_CONFIG.auth0ClientId,\n            userId: usedAuthorId,\n            transactionId: transactionId,\n            updates: updates,\n        };\n\n        const txResponse = await fetch(`${this.baseUrl}/sync`, {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${token}`,\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(payload),\n        });\n\n        if (!txResponse.ok) {\n            const responseText = await txResponse.text();\n            const errMsg = `Failed to add node: Status ${txResponse.status} ${txResponse.statusText}. Response: ${responseText}`;\n            logger.error(errMsg);\n            logger.error(\"Request payload was:\", payload);\n            throw new Error(errMsg);\n        }\n\n        if (txResponse.ok && isChecked) {\n            // Optionally update the node's isChecked status.\n            // await this.updateNode(newNodeId, { isChecked: true });\n        }\n\n        return {\n            newNodeId,\n            newRelationLabelNodeId: relationLabelNodeId,\n            parentChildRelationId,\n            referenceNodeId:\n                content?.type === \"Replacement\" && content.replacementNodeData\n                    ? content.replacementNodeData.referenceNodeId\n                    : \"\",\n            referenceCanonicalRelationId:\n                content?.type === \"Replacement\" && content.replacementNodeData\n                    ? content.replacementNodeData.referenceCanonicalRelationId\n                    : \"\",\n            isChecked: isChecked ?? undefined,\n        };\n    }\n\n    async syncData(): Promise<any> {\n        const token = await this.getAccessToken();\n        const response = await fetch(`${this.baseUrl}/sync`, {\n            method: \"GET\",\n            headers: {\n                Authorization: `Bearer ${token}`,\n                \"Content-Type\": \"application/json\",\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to sync data: ${response.statusText}`);\n        }\n        return response.json();\n    }\n\n    async getLayerData(objectIds: string[]): Promise<any> {\n        const token = await this.getAccessToken();\n        const response = await fetch(`${this.baseUrl}/layer`, {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${token}`,\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({ objectIds }),\n        });\n        if (!response.ok) {\n            throw new Error(\n                `Failed to fetch layer data: ${response.statusText}`\n            );\n        }\n        const layerData = await response.json();\n        return layerData;\n    }\n\n    /**\n     * Finds a node with exact text match under a parent node\n     * @returns The matching node or undefined\n     */\n    async findNodeByText({\n        parentNodeId,\n        nodeText,\n    }: {\n        parentNodeId: string;\n        nodeText: string;\n    }) {\n        const { parentNode, childNodes } = await this.getChildNodes({\n            parentNodeId,\n        });\n        console.log(\n            \"findNodeByText: searching for exact text match:\",\n            nodeText\n        );\n        console.log(\n            \"findNodeByText: child nodes content:\",\n            childNodes\n                .filter((node) => node)\n                .map((node) => ({\n                    id: node.id,\n                    content: node.content,\n                    textValue: node.content?.[0]?.value,\n                }))\n        );\n\n        const node = childNodes.find(\n            (node) =>\n                node &&\n                node.content &&\n                node.content.length > 0 &&\n                node.content[0].value === nodeText\n        );\n\n        console.log(\"findNodeByText: found node:\", {\n            searchedFor: nodeText,\n            foundNodeContent: node?.content?.[0]?.value,\n            node,\n        });\n\n        return node;\n    }\n\n    async getChildNodes({\n        parentNodeId,\n    }: {\n        parentNodeId: string;\n    }): Promise<{ parentNode: GraphNode; childNodes: GraphNode[] }> {\n        const layerData = await this.getLayerData([parentNodeId]);\n\n        const parentNode = layerData.data.nodesById[parentNodeId];\n\n        const childRelations = Object.values(\n            layerData.data.relationsById\n        ).filter(\n            (relation): relation is Relation =>\n                relation !== null &&\n                typeof relation === \"object\" &&\n                \"fromId\" in relation &&\n                \"toId\" in relation &&\n                \"relationTypeId\" in relation &&\n                relation.fromId === parentNodeId &&\n                relation.relationTypeId === \"child\"\n        );\n\n        const childNodes = childRelations.map((relation) => {\n            const nodeData = layerData.data.nodesById[relation.toId];\n            return nodeData;\n        });\n\n        return {\n            parentNode,\n            childNodes,\n        };\n    }\n\n    getNodeUrl(nodeId: string): string {\n        return `${this.baseUrl}/g/all/global-root-to-users/all/users-to-user-relation-id/${nodeId}`;\n    }\n}\n\nexport const parseNodeIdFromUrl = (url: string): string => {\n    const regex =\n        /^https?:\\/\\/mew-edge\\.ideaflow\\.app\\/g\\/all\\/global-root-to-users\\/all\\/users-to-user-relation-id-[^\\/]+\\/user-root-id-[^\\/]+$/;\n    if (!regex.test(url)) {\n        throw new Error(\"Invalid user node URL format\");\n    }\n    const urlParts = url.split(\"/\");\n    const lastPart = urlParts[urlParts.length - 1];\n\n    // First handle any raw %7C or %7c that might be in the string\n    let decoded = lastPart.replace(/%7C/gi, \"|\");\n    // Then do a full URL decode to handle any other encoded characters\n    decoded = decodeURIComponent(decoded);\n    // Finally ensure any remaining encoded pipes are handled\n    decoded = decoded.replace(/%7C/gi, \"|\");\n\n    return decoded;\n};\n\nexport interface GraphNode {\n    version: number;\n    id: string;\n    authorId: string;\n    createdAt: string;\n    updatedAt: string;\n    content: ContentBlock[];\n    isPublic: boolean;\n    isNewRelatedObjectsPublic: boolean;\n    relationId: string | null;\n    canonicalRelationId: string | null;\n    isChecked: boolean | null;\n}\n\nexport interface ContentBlock {\n    type: \"text\" | \"mention\"; // Could be expanded if there are other types\n    value: string;\n}\n\ninterface User {\n    id: string;\n    username: string;\n    email: string;\n}\n\nexport interface Relation {\n    fromId: string;\n    toId: string;\n    relationTypeId: string;\n}\n\ninterface SyncResponse {\n    data: {\n        usersById: {\n            [key: string]: User;\n        };\n        nodesById: {\n            [key: string]: GraphNode;\n        };\n        relationsById: {\n            [key: string]: Relation;\n        };\n    };\n}\n\ninterface TokenData {\n    access_token: string;\n    expires_in: number;\n    token_type: string;\n}\n", "/* mewClipper.ts - Integrated with the real Mew API */\n// in the future we will want to update this such that it handles login --\n// the user logs in w the same account they use for Mew, and then we\n// automatically grab the url to their user node using some lookup table\n\nimport { MewAPI, parseNodeIdFromUrl } from \"./MewService\";\nimport { Logger } from \"./utils/logger\";\n\nconst logger = new Logger(\"MewClipper\");\n\n// Helper functions for chrome.storage access\nasync function getStorageValue(key: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.get(key, (result) => {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve(result[key]);\n            }\n        });\n    });\n}\n\nasync function setStorageValue(key: string, value: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.set({ [key]: value }, () => {\n            if (chrome.runtime.lastError) {\n                reject(chrome.runtime.lastError);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\nexport const mewApi = new MewAPI();\n\n// Add this helper function after setStorageValue\nasync function getUserId(): Promise<string> {\n    const stored = await getStorageValue(\"userNodeId\");\n    if (!stored) {\n        throw new Error(\n            \"User node id not found in storage. Please complete setup properly.\"\n        );\n    }\n    // Decode the stored value\n    let decoded = decodeURIComponent(stored);\n    // Replace any occurrence of '%7C' (case-insensitive) with the pipe character '|'\n    decoded = decoded.replace(/%7C/gi, \"|\");\n    return decoded;\n}\n\n// Define a variable for the node name to allow easy changes\nconst myClipsFolderName = \"My Highlights\";\n\n/* ensureMyClips: Checks whether the \"My Clips\" folder is cached in storage.\n * If not, it retrieves the user node id (saved during setup) and calls MewAPI.addNode\n * to create a node with content \"My Clips\" under the user's node. The new node id is cached and returned.\n */\nexport async function ensureMyClips(): Promise<string> {\n    console.log(\"[MewClipper] Starting search for folder:\", myClipsFolderName);\n\n    // Get user's root URL and extract node ID\n    const userRootUrl = await getStorageValue(\"userRootUrl\");\n    if (!userRootUrl) {\n        console.error(\"[MewClipper] User root URL not found in storage.\");\n        throw new Error(\"User root URL is required for setup\");\n    }\n    console.log(\"[MewClipper] Retrieved user root URL:\", userRootUrl);\n\n    let rootNodeId: string;\n    try {\n        // Validate URL format first\n        const urlObj = new URL(userRootUrl);\n        if (!urlObj.hostname.includes(\"mew-edge.ideaflow.app\")) {\n            throw new Error(\"Invalid URL: Must be from mew-edge.ideaflow.app\");\n        }\n\n        rootNodeId = parseNodeIdFromUrl(userRootUrl);\n        if (!rootNodeId) {\n            throw new Error(\"Failed to extract root node ID from URL\");\n        }\n        console.log(\"[MewClipper] Extracted root node ID:\", rootNodeId);\n    } catch (error) {\n        console.error(\n            \"[MewClipper] Invalid user root URL stored:\",\n            userRootUrl,\n            \"Error:\",\n            error\n        );\n        throw new Error(\n            \"Invalid user root URL format. Please provide a correct user node URL.\"\n        );\n    }\n\n    // Look for existing node folder under root node\n    console.log(\n        `[MewClipper] Searching for folder with exact name '${myClipsFolderName}' under root node '${rootNodeId}'`\n    );\n    const existingNode = await mewApi.findNodeByText({\n        parentNodeId: rootNodeId,\n        nodeText: myClipsFolderName,\n    });\n\n    if (existingNode) {\n        console.log(\n            `[MewClipper] Found existing ${myClipsFolderName} folder with id:`,\n            existingNode.id\n        );\n        return existingNode.id;\n    }\n\n    // Create new node folder if it doesn't exist\n    console.log(\n        `[MewClipper] Creating '${myClipsFolderName}' folder under the root node.`\n    );\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: myClipsFolderName },\n        parentNodeId: rootNodeId,\n        authorId: await getUserId(),\n    });\n\n    const newClipsFolderId = response.newNodeId;\n    console.log(\n        `[MewClipper] '${myClipsFolderName}' folder created with id:`,\n        newClipsFolderId\n    );\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return newClipsFolderId;\n}\n\n/* getArticleNode: Retrieves (and caches) an article node for the given page.\n * If an article node for the given URL exists in storage, it is returned;\n * otherwise, a new article node is created under the My Clips folder with the page title as content.\n * An additional child node storing the URL is added for reference.\n */\nexport async function getArticleNode(\n    title: string,\n    url: string,\n    myClipsFolderId: string\n): Promise<string> {\n    const storageKey = \"articleNodes\";\n    let articleNodes =\n        ((await getStorageValue(storageKey)) as { [key: string]: string }) ||\n        {};\n    if (articleNodes[url]) {\n        console.log(\n            \"[MewClipper] Found potential existing article node for url:\",\n            url\n        );\n        // Verify the node is still a direct child of My Highlights\n        const { childNodes } = await mewApi.getChildNodes({\n            parentNodeId: myClipsFolderId,\n        });\n        const isStillChild = childNodes.some(\n            (node) => node.id === articleNodes[url]\n        );\n        if (isStillChild) {\n            console.log(\n                \"[MewClipper] Verified article node is still a child of My Highlights\"\n            );\n            return articleNodes[url];\n        }\n        console.log(\n            \"[MewClipper] Article node no longer a child of My Highlights, creating new one\"\n        );\n    }\n    console.log(\"[MewClipper] Creating new article node for\", title);\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: title },\n        parentNodeId: myClipsFolderId,\n        authorId: await getUserId(),\n    });\n    const articleNodeId = response.newNodeId;\n    // Create an additional child node to store the URL for reference.\n    await mewApi.addNode({\n        content: { type: \"text\", text: url },\n        parentNodeId: articleNodeId,\n        relationLabel: \"url\",\n        authorId: await getUserId(),\n    });\n    articleNodes[url] = articleNodeId;\n    await setStorageValue(storageKey, articleNodes);\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return articleNodeId;\n}\n\n/* addClip: Adds a clip (text) as a child node under the specified article node using the real Mew API.\n * Returns the created clip's node id.\n */\nexport async function addClip(\n    articleNodeId: string,\n    clipText: string\n): Promise<string> {\n    console.log(\"[MewClipper] Adding clip to article node:\", articleNodeId);\n    const response = await mewApi.addNode({\n        content: { type: \"text\", text: clipText },\n        parentNodeId: articleNodeId,\n        authorId: await getUserId(),\n    });\n    console.log(\"[MewClipper] Created clip node with id:\", response.newNodeId);\n    // After creating a new node, log its URL\n    console.log(\n        \"[MewClipper] Node URL:\",\n        mewApi.getNodeUrl(response.newNodeId)\n    );\n    return response.newNodeId;\n}\n", "/* YouTubeService.ts - Service for handling YouTube video transcripts */\n\n/**\n * YouTube Service for extracting transcripts from YouTube videos.\n * Uses browser-based scraping to extract directly from the YouTube page.\n */\nexport class YouTubeService {\n    // YouTube API key - loaded from environment or chrome.storage\n    private static API_KEY: string = process.env.YOUTUBE_API_KEY || \"\";\n\n    // Debug flag to enable verbose logging\n    private static readonly DEBUG = true;\n\n    constructor() {\n        // Try to load the API key from storage on initialization\n        this.loadApiKey();\n    }\n\n    /**\n     * Logs debugging information when DEBUG is enabled\n     */\n    private static debugLog(message: string, data?: any): void {\n        if (YouTubeService.DEBUG) {\n            if (data) {\n                console.log(`[YouTubeService DEBUG] ${message}`, data);\n            } else {\n                console.log(`[YouTubeService DEBUG] ${message}`);\n            }\n        }\n    }\n\n    /**\n     * Logs error information\n     */\n    private static errorLog(message: string, error?: any): void {\n        console.error(`[YouTubeService ERROR] ${message}`);\n        if (error) {\n            console.error(`[YouTubeService ERROR] Details:`, error);\n            if (error.stack) {\n                console.error(`[YouTubeService ERROR] Stack:`, error.stack);\n            }\n        }\n    }\n\n    /**\n     * Logs general information\n     */\n    private static infoLog(message: string, data?: any): void {\n        console.log(`[YouTubeService INFO] ${message}`);\n        if (data) {\n            console.log(`[YouTubeService INFO] Data:`, data);\n        }\n    }\n\n    /**\n     * Loads the YouTube API key from Chrome storage\n     */\n    private async loadApiKey(): Promise<void> {\n        try {\n            const result = await chrome.storage.local.get(\"youtubeApiKey\");\n            if (result && result.youtubeApiKey) {\n                YouTubeService.API_KEY = result.youtubeApiKey;\n                YouTubeService.debugLog(\"Loaded API key from storage\");\n            } else {\n                YouTubeService.debugLog(\"No API key found in storage\");\n            }\n        } catch (error) {\n            console.error(\"[YouTubeService] Error loading API key:\", error);\n        }\n    }\n\n    /**\n     * Sets the YouTube API key and stores it in Chrome storage\n     */\n    public async setApiKey(apiKey: string): Promise<void> {\n        try {\n            YouTubeService.API_KEY = apiKey;\n            await chrome.storage.local.set({ youtubeApiKey: apiKey });\n            YouTubeService.debugLog(\"API key saved to storage\");\n        } catch (error) {\n            console.error(\"[YouTubeService] Error saving API key:\", error);\n            throw new Error(`Failed to save API key: ${error}`);\n        }\n    }\n\n    /**\n     * Extracts video ID from a YouTube URL\n     * Supports formats:\n     * - youtube.com/watch?v=VIDEO_ID\n     * - youtu.be/VIDEO_ID\n     * - youtube.com/v/VIDEO_ID\n     * - youtube.com/embed/VIDEO_ID\n     */\n    static extractVideoId(url: string): string | null {\n        try {\n            const urlObj = new URL(url);\n\n            // Handle youtu.be format\n            if (urlObj.hostname === \"youtu.be\") {\n                return urlObj.pathname.slice(1);\n            }\n\n            // Handle youtube.com formats\n            if (\n                urlObj.hostname.includes(\"youtube.com\") ||\n                urlObj.hostname.includes(\"youtube-nocookie.com\")\n            ) {\n                // Handle watch?v= format\n                const searchParams = new URLSearchParams(urlObj.search);\n                const videoId = searchParams.get(\"v\");\n                if (videoId) return videoId;\n\n                // Handle /v/ or /embed/ formats\n                const pathMatch = urlObj.pathname.match(\n                    /^\\/(v|embed)\\/([^\\/\\?]+)/\n                );\n                if (pathMatch) {\n                    return pathMatch[2];\n                }\n            }\n\n            return null;\n        } catch (error) {\n            console.error(\"[YouTubeService] Error parsing URL:\", error);\n            return null;\n        }\n    }\n\n    /**\n     * Checks if a given URL is a YouTube video\n     */\n    static isYouTubeVideo(url: string): boolean {\n        return !!YouTubeService.extractVideoId(url);\n    }\n\n    /**\n     * Main method to fetch transcript for a YouTube video\n     * Uses browser-based scraping\n     */\n    async getTranscript(videoId: string): Promise<string> {\n        YouTubeService.infoLog(\n            `Starting transcript fetch for video ID: ${videoId}`\n        );\n        YouTubeService.infoLog(\n            `Video URL: https://www.youtube.com/watch?v=${videoId}`\n        );\n\n        // DEBUG: Add marker to trace transcript fetching flow\n        console.log(\"[TRANSCRIPT DEBUG] Starting transcript fetch process\");\n\n        return await this.extractTranscriptWithBrowserScraping(videoId);\n    }\n\n    /**\n     * Extract transcript by injecting a content script that scrapes the YouTube page\n     */\n    private async extractTranscriptWithBrowserScraping(\n        videoId: string\n    ): Promise<string> {\n        YouTubeService.infoLog(\n            \"Starting browser-based transcript extraction for video ID: \" +\n                videoId\n        );\n\n        // DEBUG: Add marker to indicate browser scraping started\n        console.log(\"[TRANSCRIPT DEBUG] Browser-based extraction started\");\n\n        // Get the current active tab\n        const tabs = await chrome.tabs.query({\n            active: true,\n            currentWindow: true,\n        });\n        if (!tabs || tabs.length === 0) {\n            throw new Error(\"No active tab found to perform browser scraping\");\n        }\n        const tab = tabs[0];\n\n        // Check if the current tab is already on the YouTube video page\n        let isOnCorrectPage = false;\n        if (tab.url && YouTubeService.isYouTubeVideo(tab.url)) {\n            const currentVideoId = YouTubeService.extractVideoId(tab.url);\n            isOnCorrectPage = currentVideoId === videoId;\n        }\n\n        // If not on the correct page, navigate to it\n        if (!isOnCorrectPage) {\n            YouTubeService.infoLog(\n                \"Current tab is not on the target YouTube video, navigating to it\"\n            );\n\n            if (!tab.id) {\n                throw new Error(\"Tab ID is undefined, cannot navigate\");\n            }\n\n            try {\n                // DEBUG: Log navigation start\n                console.log(\n                    \"[TRANSCRIPT DEBUG] Navigating to YouTube video page\"\n                );\n\n                await chrome.tabs.update(tab.id, {\n                    url: `https://www.youtube.com/watch?v=${videoId}`,\n                });\n\n                // Wait for the page to load\n                await new Promise((resolve) => setTimeout(resolve, 3000));\n\n                // DEBUG: Log navigation completion\n                console.log(\n                    \"[TRANSCRIPT DEBUG] Navigation complete, waited 3s for page to load\"\n                );\n            } catch (error) {\n                YouTubeService.errorLog(\n                    \"Failed to navigate to YouTube video:\",\n                    error\n                );\n                throw new Error(\"Failed to navigate to YouTube video page\");\n            }\n        } else {\n            // DEBUG: Log already on correct page\n            console.log(\n                \"[TRANSCRIPT DEBUG] Already on correct YouTube video page\"\n            );\n        }\n\n        if (!tab.id) {\n            throw new Error(\n                \"Tab ID is undefined, cannot inject content script\"\n            );\n        }\n\n        // Inject and execute a content script that extracts the transcript\n        try {\n            // DEBUG: Add marker before content script injection\n            console.log(\n                \"[TRANSCRIPT DEBUG] Injecting content script to extract transcript\"\n            );\n\n            const results = await chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                func: function () {\n                    console.log(\n                        \"[Transcript Extractor] Starting transcript extraction from page\"\n                    );\n\n                    // DEBUG: Signal that we're inside the content script\n                    console.log(\n                        \"[TRANSCRIPT DEBUG][Content Script] Starting transcript extraction\"\n                    );\n\n                    try {\n                        // First try: Look for transcript in the UI\n                        // Step 1: Open the transcript panel if it exists\n                        const findTranscriptButton = () => {\n                            // DEBUG: Check buttons on the page\n                            const menuButtons = Array.from(\n                                document.querySelectorAll(\"button\")\n                            );\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Found \" +\n                                    menuButtons.length +\n                                    \" buttons on the page\"\n                            );\n\n                            // Log some button text for debugging\n                            if (menuButtons.length > 0) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Button texts sample: \" +\n                                        menuButtons\n                                            .slice(\n                                                0,\n                                                Math.min(5, menuButtons.length)\n                                            )\n                                            .map(\n                                                (b) => b.textContent || \"empty\"\n                                            )\n                                            .join(\", \")\n                                );\n                            }\n\n                            const transcriptButton = menuButtons.find(\n                                (button) =>\n                                    button.textContent?.includes(\n                                        \"Show transcript\"\n                                    ) ||\n                                    button.textContent?.includes(\n                                        \"Open transcript\"\n                                    )\n                            );\n\n                            if (transcriptButton) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Found transcript button with text: \" +\n                                        (transcriptButton.textContent ||\n                                            \"empty\")\n                                );\n                            } else {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] No transcript button found\"\n                                );\n                            }\n\n                            return transcriptButton;\n                        };\n\n                        // Try to find and click the transcript button\n                        const transcriptButton = findTranscriptButton();\n                        if (transcriptButton) {\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Clicking transcript button\"\n                            );\n                            transcriptButton.click();\n                            // Allow time for transcript to load\n                            setTimeout(() => {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Waited for transcript to load\"\n                                );\n                            }, 1000);\n                        } else {\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] No transcript button found, will try to find transcript panel directly\"\n                            );\n                        }\n\n                        // Step 2: Find the transcript panel and extract text\n                        const transcriptPanel =\n                            document.querySelector(\"ytd-transcript-renderer\") ||\n                            document.querySelector('[id=\"transcript-panel\"]') ||\n                            document.querySelector('[id=\"transcript\"]');\n\n                        // DEBUG: Check for transcript panel\n                        console.log(\n                            \"[TRANSCRIPT DEBUG][Content Script] Transcript panel found: \" +\n                                (transcriptPanel ? \"Yes\" : \"No\")\n                        );\n                        if (transcriptPanel) {\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Transcript panel element: \" +\n                                    transcriptPanel.tagName +\n                                    \" with class: \" +\n                                    (transcriptPanel.className || \"none\")\n                            );\n\n                            // Find all transcript segments (timestamp + text pairs)\n                            const segments =\n                                transcriptPanel.querySelectorAll(\n                                    \"ytd-transcript-segment-renderer\"\n                                ) ||\n                                transcriptPanel.querySelectorAll(\".segment\");\n\n                            // DEBUG: Check for transcript segments\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Segments found: \" +\n                                    (segments ? segments.length : 0)\n                            );\n\n                            if (segments && segments.length > 0) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Processing \" +\n                                        segments.length +\n                                        \" transcript segments\"\n                                );\n                                let transcript = \"\";\n\n                                Array.from(segments).forEach((segment) => {\n                                    // Get timestamp\n                                    const timestampElem =\n                                        segment.querySelector(\n                                            \".segment-timestamp\"\n                                        ) ||\n                                        segment.querySelector(\n                                            '[class*=\"timestamp\"]'\n                                        );\n\n                                    // Get text\n                                    const textElem =\n                                        segment.querySelector(\n                                            \".segment-text\"\n                                        ) ||\n                                        segment.querySelector(\n                                            '[class*=\"text\"]'\n                                        );\n\n                                    if (timestampElem && textElem) {\n                                        const timestamp =\n                                            timestampElem.textContent?.trim() ||\n                                            \"\";\n                                        const text =\n                                            textElem.textContent?.trim() || \"\";\n\n                                        if (timestamp && text) {\n                                            // Format as [MM:SS]\n                                            const formattedTimestamp = `[${timestamp}]`;\n                                            transcript += `${formattedTimestamp} ${text}\\n`;\n                                        }\n                                    }\n                                });\n\n                                if (transcript.trim()) {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Successfully extracted transcript with \" +\n                                            transcript.split(\"\\n\").length +\n                                            \" lines\"\n                                    );\n                                    return { transcript: transcript.trim() };\n                                } else {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Extracted empty transcript\"\n                                    );\n                                }\n                            } else {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] No transcript segments found in panel\"\n                                );\n                            }\n                        } else {\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] No transcript panel found\"\n                            );\n                        }\n\n                        // If we couldn't find the transcript through the UI elements, look for it in the page data\n                        console.log(\n                            \"[TRANSCRIPT DEBUG][Content Script] Looking for transcript data in script tags\"\n                        );\n                        const scriptTags = document.querySelectorAll(\"script\");\n                        console.log(\n                            \"[TRANSCRIPT DEBUG][Content Script] Found \" +\n                                scriptTags.length +\n                                \" script tags\"\n                        );\n\n                        let found = false;\n\n                        for (let i = 0; i < scriptTags.length; i++) {\n                            const script = scriptTags[i];\n                            const content = script.textContent || \"\";\n\n                            // Look for transcript data in YouTube's initial data\n                            if (\n                                content.includes('\"transcriptRenderer\"') ||\n                                content.includes('\"captionTracks\"')\n                            ) {\n                                // This is a basic extraction - in a real implementation, you'd parse the JSON and extract properly\n                                found = true;\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Found transcript data in script tag #\" +\n                                        i\n                                );\n\n                                // Try to extract the transcript from visual elements directly\n                                try {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Attempting to extract transcript from visible elements\"\n                                    );\n\n                                    // Look for the transcript elements on the page that might be visible\n                                    const transcriptItems =\n                                        document.querySelectorAll(\n                                            \"yt-formatted-string.segment-text\"\n                                        );\n                                    const timestampItems =\n                                        document.querySelectorAll(\n                                            \"span.segment-timestamp\"\n                                        );\n\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Found \" +\n                                            transcriptItems.length +\n                                            \" text segments and \" +\n                                            timestampItems.length +\n                                            \" timestamps\"\n                                    );\n\n                                    // If we found transcript items, let's try to process them\n                                    if (\n                                        transcriptItems.length > 0 &&\n                                        timestampItems.length > 0 &&\n                                        transcriptItems.length ===\n                                            timestampItems.length\n                                    ) {\n                                        console.log(\n                                            \"[TRANSCRIPT DEBUG][Content Script] Processing visible transcript elements\"\n                                        );\n                                        let transcript = \"\";\n\n                                        for (\n                                            let i = 0;\n                                            i < transcriptItems.length;\n                                            i++\n                                        ) {\n                                            const text =\n                                                transcriptItems[\n                                                    i\n                                                ].textContent?.trim() || \"\";\n                                            const timestamp =\n                                                timestampItems[\n                                                    i\n                                                ].textContent?.trim() || \"\";\n                                            if (text && timestamp) {\n                                                const formattedTimestamp = `[${timestamp}]`;\n                                                transcript += `${formattedTimestamp} ${text}\\n`;\n                                            }\n                                        }\n\n                                        if (transcript.trim()) {\n                                            console.log(\n                                                \"[TRANSCRIPT DEBUG][Content Script] Successfully extracted transcript from visible elements\"\n                                            );\n                                            return {\n                                                transcript: transcript.trim(),\n                                            };\n                                        }\n                                    }\n\n                                    // If we reach here, the direct element approach didn't work\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Failed to extract transcript from visible elements\"\n                                    );\n                                } catch (extractError) {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Error extracting from visible elements: \" +\n                                            (extractError instanceof Error\n                                                ? extractError.message\n                                                : String(extractError))\n                                    );\n                                }\n\n                                // Let's try one more alternative approach - by using new methods to find the transcript\n                                try {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Trying alternative transcript extraction method\"\n                                    );\n\n                                    // Look for the transcript container in YouTube's new UI\n                                    const transcriptContainer =\n                                        document.querySelector(\n                                            \"ytd-transcript-search-panel-renderer\"\n                                        ) ||\n                                        document.querySelector(\n                                            \"ytd-transcript-renderer\"\n                                        );\n\n                                    if (transcriptContainer) {\n                                        console.log(\n                                            \"[TRANSCRIPT DEBUG][Content Script] Found transcript container\"\n                                        );\n\n                                        // Get all segments\n                                        const segmentRows =\n                                            transcriptContainer.querySelectorAll(\n                                                \"ytd-transcript-segment-renderer, ytd-transcript-segment-list-renderer div.segment\"\n                                            );\n                                        console.log(\n                                            \"[TRANSCRIPT DEBUG][Content Script] Found \" +\n                                                segmentRows.length +\n                                                \" segment rows\"\n                                        );\n\n                                        if (segmentRows.length > 0) {\n                                            let transcript = \"\";\n\n                                            segmentRows.forEach((row) => {\n                                                // Try different ways to get timestamp and text\n                                                const timestamp =\n                                                    row\n                                                        .querySelector(\n                                                            '[class*=\"timestamp\"]'\n                                                        )\n                                                        ?.textContent?.trim() ||\n                                                    row\n                                                        .querySelector(\n                                                            \"div.segment-timestamp\"\n                                                        )\n                                                        ?.textContent?.trim() ||\n                                                    \"\";\n\n                                                const text =\n                                                    row\n                                                        .querySelector(\n                                                            '[class*=\"segment-text\"]'\n                                                        )\n                                                        ?.textContent?.trim() ||\n                                                    row\n                                                        .querySelector(\n                                                            \"div.segment-text\"\n                                                        )\n                                                        ?.textContent?.trim() ||\n                                                    row\n                                                        .querySelector(\n                                                            \"yt-formatted-string\"\n                                                        )\n                                                        ?.textContent?.trim() ||\n                                                    \"\";\n\n                                                if (timestamp && text) {\n                                                    const formattedTimestamp = `[${timestamp}]`;\n                                                    transcript += `${formattedTimestamp} ${text}\\n`;\n                                                }\n                                            });\n\n                                            if (transcript.trim()) {\n                                                console.log(\n                                                    \"[TRANSCRIPT DEBUG][Content Script] Successfully extracted transcript with alternative method\"\n                                                );\n                                                return {\n                                                    transcript:\n                                                        transcript.trim(),\n                                                };\n                                            }\n                                        }\n                                    }\n                                } catch (altError) {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Error with alternative extraction: \" +\n                                            (altError instanceof Error\n                                                ? altError.message\n                                                : String(altError))\n                                    );\n                                }\n\n                                break;\n                            }\n                        }\n\n                        if (found) {\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Found transcript data in page, but all extraction methods failed\"\n                            );\n                            // Instead of returning an error, let's try a last-resort approach: grab the visible transcript text\n                            // from the transcript panel that's visually open on the page\n                            try {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Attempting last-resort extraction from any visible transcript text\"\n                                );\n\n                                // Get any visible text that looks like a transcript\n                                const visibleTranscriptPanel =\n                                    document.querySelector(\n                                        \".ytd-transcript-renderer\"\n                                    ) ||\n                                    document.querySelector(\n                                        '[id*=\"transcript\"]'\n                                    ) ||\n                                    document.querySelector(\n                                        '[class*=\"transcript\"]'\n                                    );\n\n                                if (visibleTranscriptPanel) {\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Found visible transcript panel\"\n                                    );\n                                    const fullText =\n                                        visibleTranscriptPanel.textContent ||\n                                        \"\";\n\n                                    if (fullText.trim().length > 100) {\n                                        // If we have substantial text\n                                        console.log(\n                                            \"[TRANSCRIPT DEBUG][Content Script] Extracted text content of length: \" +\n                                                fullText.length\n                                        );\n\n                                        // Basic processing to create a formatted transcript\n                                        const lines = fullText\n                                            .split(\"\\n\")\n                                            .map((line) => line.trim())\n                                            .filter((line) => line.length > 0);\n\n                                        if (lines.length > 0) {\n                                            // Attempt to identify timestamp patterns and format as transcript\n                                            let transcript = \"\";\n                                            let currentTimestamp = \"\";\n\n                                            for (const line of lines) {\n                                                // Check if line looks like a timestamp (e.g., \"0:12\" or \"12:34\")\n                                                if (\n                                                    /^\\d+:\\d+$/.test(\n                                                        line.trim()\n                                                    )\n                                                ) {\n                                                    currentTimestamp =\n                                                        line.trim();\n                                                } else if (\n                                                    currentTimestamp &&\n                                                    line.length > 3\n                                                ) {\n                                                    // This looks like transcript text\n                                                    transcript += `[${currentTimestamp}] ${line}\\n`;\n                                                    currentTimestamp = \"\"; // Reset for next pair\n                                                }\n                                            }\n\n                                            if (transcript.trim()) {\n                                                console.log(\n                                                    \"[TRANSCRIPT DEBUG][Content Script] Successfully created transcript from visible text\"\n                                                );\n                                                return {\n                                                    transcript:\n                                                        transcript.trim(),\n                                                };\n                                            }\n                                        }\n                                    }\n                                }\n                            } catch (visibleTextError) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Error extracting visible text: \" +\n                                        (visibleTextError instanceof Error\n                                            ? visibleTextError.message\n                                            : String(visibleTextError))\n                                );\n                            }\n\n                            // Instead of returning an error, let's extract the raw transcript data\n                            console.log(\n                                \"[TRANSCRIPT DEBUG][Content Script] Applying raw transcript extraction\"\n                            );\n\n                            // Get all text content from any element that might contain transcript data\n                            const allPossibleTranscriptElements =\n                                document.querySelectorAll(\n                                    '[class*=\"transcript\"] yt-formatted-string, ' +\n                                        '[id*=\"transcript\"] yt-formatted-string, ' +\n                                        \"ytd-transcript-segment-renderer, \" +\n                                        \".ytd-transcript-renderer yt-formatted-string, \" +\n                                        \".segment-text, \" +\n                                        '[class*=\"segment-text\"]'\n                                );\n\n                            if (\n                                allPossibleTranscriptElements &&\n                                allPossibleTranscriptElements.length > 0\n                            ) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Found \" +\n                                        allPossibleTranscriptElements.length +\n                                        \" possible transcript elements\"\n                                );\n\n                                // Extract text content from all elements\n                                let rawTranscript: string[] = [];\n                                allPossibleTranscriptElements.forEach((el) => {\n                                    const text = el.textContent?.trim();\n                                    if (text && text.length > 0) {\n                                        rawTranscript.push(text);\n                                    }\n                                });\n\n                                if (rawTranscript.length > 0) {\n                                    // Simple deduplication\n                                    const uniqueLines = [\n                                        ...new Set(rawTranscript),\n                                    ];\n\n                                    // Format the transcript (without timestamps if we can't extract them)\n                                    const formattedTranscript =\n                                        uniqueLines.join(\"\\n\");\n\n                                    console.log(\n                                        \"[TRANSCRIPT DEBUG][Content Script] Successfully extracted raw transcript with \" +\n                                            uniqueLines.length +\n                                            \" lines\"\n                                    );\n\n                                    return {\n                                        transcript: formattedTranscript,\n                                        note: \"Raw extraction without timestamps\",\n                                    };\n                                }\n                            }\n\n                            // If we still can't extract anything, try one last desperate approach\n                            try {\n                                const anyTranscriptContent =\n                                    document.querySelector(\n                                        '[class*=\"transcript-container\"]'\n                                    );\n                                if (anyTranscriptContent) {\n                                    const rawText =\n                                        anyTranscriptContent.textContent?.trim();\n                                    if (rawText && rawText.length > 50) {\n                                        return {\n                                            transcript:\n                                                \"TRANSCRIPT CONTENT:\\n\\n\" +\n                                                rawText,\n                                            note: \"Last resort extraction\",\n                                        };\n                                    }\n                                }\n                            } catch (e) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG][Content Script] Last resort extraction failed\"\n                                );\n                            }\n\n                            // Only return error if all extraction attempts fail\n                            return {\n                                error: \"Found transcript data in page, but all extraction methods failed\",\n                            };\n                        }\n\n                        console.log(\n                            \"[TRANSCRIPT DEBUG][Content Script] Could not find transcript on YouTube page\"\n                        );\n                        return {\n                            error: \"Could not find transcript on YouTube page\",\n                        };\n                    } catch (e) {\n                        console.log(\n                            \"[TRANSCRIPT DEBUG][Content Script] Error occurred during extraction: \" +\n                                (e instanceof Error ? e.message : String(e))\n                        );\n                        return {\n                            error: `Error extracting transcript: ${\n                                e instanceof Error ? e.message : String(e)\n                            }`,\n                        };\n                    }\n                },\n            });\n\n            // DEBUG: Log content script execution result\n            console.log(\n                \"[TRANSCRIPT DEBUG] Content script execution completed\"\n            );\n\n            if (!results || results.length === 0 || !results[0].result) {\n                console.log(\n                    \"[TRANSCRIPT DEBUG] Script execution failed or returned no result\"\n                );\n                throw new Error(\n                    \"Script execution failed or returned no result\"\n                );\n            }\n\n            const transcriptResult = results[0].result;\n            console.log(\n                \"[TRANSCRIPT DEBUG] Script execution returned result:\",\n                transcriptResult\n            );\n\n            if (transcriptResult.error) {\n                console.log(\n                    \"[TRANSCRIPT DEBUG] Transcript extraction failed with error: \" +\n                        transcriptResult.error\n                );\n                throw new Error(\n                    `Transcript extraction failed: ${transcriptResult.error}`\n                );\n            }\n\n            if (\n                !transcriptResult.transcript ||\n                transcriptResult.transcript.trim() === \"\"\n            ) {\n                console.log(\"[TRANSCRIPT DEBUG] Extracted transcript is empty\");\n                throw new Error(\"Extracted transcript is empty\");\n            }\n\n            // DEBUG: Log successful extraction details\n            console.log(\n                \"[TRANSCRIPT DEBUG] Successfully extracted transcript with \" +\n                    transcriptResult.transcript.split(\"\\n\").length +\n                    \" lines\"\n            );\n\n            YouTubeService.infoLog(\n                `Successfully extracted transcript from YouTube page, length: ${transcriptResult.transcript.length} chars`\n            );\n\n            // Return the extracted transcript\n            return transcriptResult.transcript;\n        } catch (error) {\n            // DEBUG: Log extraction error\n            console.log(\n                \"[TRANSCRIPT DEBUG] Error during browser transcript extraction:\",\n                error\n            );\n\n            YouTubeService.errorLog(\n                \"Error during browser transcript extraction:\",\n                error\n            );\n            const err = error as Error;\n            throw new Error(\n                `Browser-based transcript extraction failed: ${err.message}`\n            );\n        }\n    }\n}\n", "/* background.ts - Background script for Mew Web Clipper extension */\n\nimport { ensureMyClips, getArticleNode, addClip } from \"./mewClipper\";\nimport { mewApi } from \"./mewClipper\";\nimport { YouTubeService } from \"./services/YouTubeService\";\n\n// Global error handler for the service worker\nself.addEventListener(\"error\", (event) => {\n    console.error(\"[ServiceWorker] Uncaught error:\", event.error);\n});\n\n// Global unhandled promise rejection handler\nself.addEventListener(\"unhandledrejection\", (event) => {\n    console.error(\"[ServiceWorker] Unhandled promise rejection:\", event.reason);\n});\n\nconst youtubeService = new YouTubeService();\n\n// Function to inject notification system into a tab\nasync function injectNotificationSystem(tabId: number) {\n    // Inject CSS\n    await chrome.scripting.insertCSS({\n        target: { tabId },\n        files: [\"notification.css\"],\n    });\n\n    // Inject notification script\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        files: [\"notification.js\"],\n    });\n}\n\n// Function to show notification in a tab\nasync function showNotification(tabId: number, message: string) {\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        func: (msg) => {\n            // Get the showNotification function from the injected script\n            const showNotification = (window as any).showNotification;\n            if (showNotification) {\n                showNotification(msg);\n            }\n        },\n        args: [message],\n    });\n}\n\nconsole.log(\"[Background] Mew Web Clipper extension background initialized.\");\n\n// Clear storage command for development/testing\nchrome.runtime.onInstalled.addListener(async () => {\n    console.log(\n        \"[Background] onInstalled event fired. Creating context menu items.\"\n    );\n    chrome.contextMenus.create({\n        id: \"clearStorage\",\n        title: \"Clear Mew Storage (Debug)\",\n        contexts: [\"page\"],\n    });\n    chrome.contextMenus.create({\n        id: \"saveSelection\",\n        title: \"Save Selection to Mew\",\n        contexts: [\"selection\"],\n    });\n    chrome.contextMenus.create({\n        id: \"savePage\",\n        title: \"Save Page to Mew\",\n        contexts: [\"page\"],\n    });\n\n    // Add YouTube API key configuration menu item\n    chrome.contextMenus.create({\n        id: \"setYouTubeApiKey\",\n        title: \"Set YouTube API Key\",\n        contexts: [\"page\"],\n    });\n\n    // Check if both user node id and root url have been properly set\n    const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n        \"userNodeId\",\n        \"userRootUrl\",\n    ]);\n    if (\n        !userNodeId ||\n        !userRootUrl ||\n        !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n    ) {\n        console.log(\n            \"[Background] Missing or invalid user configuration. Opening setup window.\"\n        );\n        // Clear any potentially invalid stored values\n        await chrome.storage.local.remove([\"userNodeId\", \"userRootUrl\"]);\n        chrome.windows.create({\n            url: \"setup.html\",\n            type: \"normal\",\n            width: 600,\n            height: 400,\n        });\n    } else {\n        console.log(\"[Background] User configuration verified:\", {\n            userNodeId,\n            userRootUrl,\n        });\n    }\n});\n\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n    console.log(\"[Background] Context menu clicked. Info:\", info);\n    if (!tab || !tab.id) {\n        console.error(\"[Background] No tab information available.\");\n        return;\n    }\n\n    try {\n        // Check if we have valid configuration before proceeding\n        const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n            \"userNodeId\",\n            \"userRootUrl\",\n        ]);\n        if (\n            !userNodeId ||\n            !userRootUrl ||\n            !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n        ) {\n            throw new Error(\"Please complete the Mew Web Clipper setup first\");\n        }\n\n        if (info.menuItemId === \"clearStorage\") {\n            await chrome.storage.local.clear();\n            console.log(\"[Background] Cleared local storage\");\n            return;\n        }\n\n        if (info.menuItemId === \"setYouTubeApiKey\") {\n            // Prompt user for YouTube API key\n            if (tab.id) {\n                await injectNotificationSystem(tab.id);\n                const result = await chrome.scripting.executeScript({\n                    target: { tabId: tab.id },\n                    func: () => {\n                        return prompt(\"Enter your YouTube Data API key:\");\n                    },\n                });\n\n                if (result && result[0] && result[0].result) {\n                    const apiKey = result[0].result;\n                    try {\n                        await youtubeService.setApiKey(apiKey);\n                        await showNotification(\n                            tab.id,\n                            \"YouTube API key saved successfully\"\n                        );\n                        console.log(\"[Background] YouTube API key saved\");\n                    } catch (error) {\n                        console.error(\n                            \"[Background] Error saving YouTube API key:\",\n                            error\n                        );\n                        await showNotification(\n                            tab.id,\n                            \"Error saving YouTube API key\"\n                        );\n                    }\n                } else {\n                    console.log(\n                        \"[Background] API key setting cancelled by user\"\n                    );\n                    await showNotification(tab.id, \"API key setting cancelled\");\n                }\n            }\n            return;\n        }\n\n        // Optimistic UI: Show notification immediately\n        if (tab.id) {\n            await injectNotificationSystem(tab.id);\n            await showNotification(tab.id, \"Saving to My Highlights...\");\n        }\n\n        const myClipsFolderId = await ensureMyClips();\n        console.log(\"[Mew API] ensureMyClips response:\", myClipsFolderId);\n\n        if (!tab.title || !tab.url) {\n            console.error(\"[Background] Tab missing title or url.\");\n            return;\n        }\n\n        const articleNodeId = await getArticleNode(\n            tab.title,\n            tab.url,\n            myClipsFolderId\n        );\n        console.log(\"[Mew API] getArticleNode response:\", articleNodeId);\n\n        // Handle YouTube video transcript\n        if (YouTubeService.isYouTubeVideo(tab.url)) {\n            try {\n                const videoId = YouTubeService.extractVideoId(tab.url);\n                if (!videoId) {\n                    throw new Error(\"Failed to extract video ID\");\n                }\n\n                // Check if Transcript node already exists\n                const existingTranscript = await mewApi.findNodeByText({\n                    parentNodeId: articleNodeId,\n                    nodeText: \"Transcript\",\n                });\n\n                // Only create a Transcript node if we can successfully fetch a transcript\n                if (!existingTranscript) {\n                    console.log(\"[Background] Fetching YouTube transcript\");\n\n                    try {\n                        // First try to get transcript with our multi-approach service\n                        let transcript = await youtubeService.getTranscript(\n                            videoId\n                        );\n\n                        // Check if the result is a caption URL that needs to be fetched\n                        if (transcript.startsWith(\"CAPTION_URL:\")) {\n                            console.log(\n                                \"[Background] Received caption URL from page scraping\"\n                            );\n                            const captionUrl = transcript.substring(\n                                \"CAPTION_URL:\".length\n                            );\n\n                            try {\n                                // Fetch the caption URL\n                                const response = await fetch(captionUrl);\n                                if (response.ok) {\n                                    const captionText = await response.text();\n\n                                    // Parse the XML caption data\n                                    if (captionText.includes(\"<text \")) {\n                                        // Simple XML parsing to extract captions\n                                        const parser = new DOMParser();\n                                        const xmlDoc = parser.parseFromString(\n                                            captionText,\n                                            \"text/xml\"\n                                        );\n                                        const textElements =\n                                            xmlDoc.getElementsByTagName(\"text\");\n\n                                        let parsedTranscript = \"\";\n                                        for (\n                                            let i = 0;\n                                            i < textElements.length;\n                                            i++\n                                        ) {\n                                            const element = textElements[i];\n                                            const text =\n                                                element.textContent || \"\";\n                                            const start =\n                                                element.getAttribute(\"start\");\n\n                                            if (text.trim() && start) {\n                                                const seconds =\n                                                    parseFloat(start);\n                                                const minutes = Math.floor(\n                                                    seconds / 60\n                                                );\n                                                const remainingSeconds =\n                                                    Math.floor(seconds % 60);\n                                                const timestamp = `[${minutes\n                                                    .toString()\n                                                    .padStart(\n                                                        2,\n                                                        \"0\"\n                                                    )}:${remainingSeconds\n                                                    .toString()\n                                                    .padStart(2, \"0\")}]`;\n\n                                                parsedTranscript += `${timestamp} ${text.trim()}\\n`;\n                                            }\n                                        }\n\n                                        if (parsedTranscript.trim()) {\n                                            transcript =\n                                                parsedTranscript.trim();\n                                            console.log(\n                                                \"[Background] Successfully parsed caption URL data\"\n                                            );\n                                        }\n                                    }\n                                }\n                            } catch (captionError) {\n                                console.error(\n                                    \"[Background] Error fetching caption URL:\",\n                                    captionError\n                                );\n                            }\n                        }\n\n                        // Only create the Transcript node if we have a valid transcript\n                        if (transcript && transcript.trim()) {\n                            // Create Transcript node\n                            const transcriptNodeId = await addClip(\n                                articleNodeId,\n                                \"Transcript\"\n                            );\n                            console.log(\n                                \"[Background] Created Transcript node:\",\n                                transcriptNodeId\n                            );\n\n                            // Add transcript text as child of Transcript node\n                            const transcriptTextNodeId = await addClip(\n                                transcriptNodeId,\n                                transcript\n                            );\n                            console.log(\n                                \"[Background] Added transcript text node:\",\n                                transcriptTextNodeId\n                            );\n\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    \"Saved page with transcript to My Highlights\"\n                                );\n                            }\n                        } else {\n                            console.log(\n                                \"[Background] No valid transcript found, not creating Transcript node\"\n                            );\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    \"Saved page to My Highlights\"\n                                );\n                            }\n                        }\n                    } catch (transcriptError) {\n                        console.error(\n                            \"[Background] All transcript fetching approaches failed:\",\n                            transcriptError\n                        );\n\n                        // Show a detailed error message so we can debug the issue\n                        const errorMessage =\n                            transcriptError instanceof Error\n                                ? transcriptError.message\n                                : String(transcriptError);\n\n                        console.error(\n                            \"[Background] Transcript error details:\",\n                            errorMessage\n                        );\n\n                        // Create a transcript node with the error information for debugging\n                        try {\n                            const transcriptNodeId = await addClip(\n                                articleNodeId,\n                                \"Transcript (Error Details)\"\n                            );\n\n                            await addClip(\n                                transcriptNodeId,\n                                `Transcript extraction failed with error: ${errorMessage}\\n\\nThis is a debug node to help diagnose the issue.`\n                            );\n\n                            console.log(\n                                \"[Background] Created transcript error debug node:\",\n                                transcriptNodeId\n                            );\n                        } catch (debugNodeError) {\n                            console.error(\n                                \"[Background] Failed to create debug node:\",\n                                debugNodeError\n                            );\n                        }\n\n                        // Don't create a real transcript node since extraction failed\n                        if (tab.id) {\n                            await showNotification(\n                                tab.id,\n                                `Saved page to My Highlights (transcript error: ${errorMessage.substring(\n                                    0,\n                                    50\n                                )}${errorMessage.length > 50 ? \"...\" : \"\"})`\n                            );\n                        }\n                    }\n                } else {\n                    console.log(\n                        \"[Background] Transcript node already exists, skipping transcript fetch\"\n                    );\n\n                    if (tab.id) {\n                        await showNotification(\n                            tab.id,\n                            \"Saved page to My Highlights\"\n                        );\n                    }\n                }\n            } catch (error) {\n                console.error(\n                    \"[Background] Error processing YouTube page:\",\n                    error\n                );\n                // Continue with normal page save even if transcript fails\n                if (tab.id) {\n                    await showNotification(\n                        tab.id,\n                        \"Saved page to My Highlights (transcript unavailable)\"\n                    );\n                }\n            }\n        }\n\n        if (info.menuItemId === \"saveSelection\" && info.selectionText) {\n            console.log(\"[Background] Saving selection clip.\");\n            const clipNodeId = await addClip(articleNodeId, info.selectionText);\n            console.log(\"[Mew API] addClip response:\", clipNodeId);\n            console.log(\"[Background] Clip saved with node id:\", clipNodeId);\n            if (tab.id) {\n                await showNotification(\n                    tab.id,\n                    \"Selection saved to My Highlights\"\n                );\n            }\n        } else if (info.menuItemId === \"savePage\") {\n            console.log(\"[Background] Saving full page capture.\");\n            // For full page capture we simply ensure the article node exists\n            console.log(\n                \"[Background] Page saved. Article node id:\",\n                articleNodeId\n            );\n            if (tab.id) {\n                await showNotification(tab.id, \"Page saved to My Highlights\");\n            }\n        }\n    } catch (err) {\n        console.error(\"[Background] Error processing context menu click:\", err);\n        if (tab && tab.id) {\n            await showNotification(tab.id, \"Error saving to My Highlights\");\n        }\n    }\n});\n\nchrome.commands.onCommand.addListener(async (command) => {\n    console.log(\"[Background] Command received:\", command);\n    if (command === \"clipPage\") {\n        try {\n            const tabs = await chrome.tabs.query({\n                active: true,\n                currentWindow: true,\n            });\n            if (!tabs || tabs.length === 0) {\n                console.error(\"[Background] No active tab found.\");\n                return;\n            }\n            const tab = tabs[0];\n            if (!tab.title || !tab.url) {\n                console.error(\"[Background] Active tab missing title or url.\");\n                return;\n            }\n\n            // Check if we have valid configuration before proceeding\n            const { userNodeId, userRootUrl } = await chrome.storage.local.get([\n                \"userNodeId\",\n                \"userRootUrl\",\n            ]);\n            if (\n                !userNodeId ||\n                !userRootUrl ||\n                !userRootUrl.includes(\"mew-edge.ideaflow.app\")\n            ) {\n                throw new Error(\n                    \"Please complete the Mew Web Clipper setup first\"\n                );\n            }\n\n            // Optimistic UI: Show notification immediately\n            if (tab.id) {\n                await injectNotificationSystem(tab.id);\n                await showNotification(\n                    tab.id,\n                    \"Saving page to My Highlights...\"\n                );\n            }\n\n            const myClipsFolderId = await ensureMyClips();\n            console.log(\"[Mew API] ensureMyClips response:\", myClipsFolderId);\n            const articleNodeId = await getArticleNode(\n                tab.title,\n                tab.url,\n                myClipsFolderId\n            );\n            console.log(\"[Mew API] getArticleNode response:\", articleNodeId);\n\n            // Handle YouTube video transcript\n            if (YouTubeService.isYouTubeVideo(tab.url)) {\n                try {\n                    const videoId = YouTubeService.extractVideoId(tab.url);\n                    if (!videoId) {\n                        throw new Error(\"Failed to extract video ID\");\n                    }\n\n                    // Check if Transcript node already exists\n                    console.log(\n                        \"[TRANSCRIPT DEBUG] Checking if Transcript node already exists under article node:\",\n                        articleNodeId\n                    );\n                    const existingTranscript = await mewApi.findNodeByText({\n                        parentNodeId: articleNodeId,\n                        nodeText: \"Transcript\",\n                    });\n                    console.log(\n                        \"[TRANSCRIPT DEBUG] Existing transcript node check result:\",\n                        existingTranscript\n                    );\n\n                    // Only create a Transcript node if we can successfully fetch a transcript\n                    if (!existingTranscript) {\n                        console.log(\"[Background] Fetching YouTube transcript\");\n                        console.log(\n                            \"[TRANSCRIPT DEBUG] No existing transcript node found, will attempt to create one\"\n                        );\n\n                        try {\n                            // First try to get transcript with our multi-approach service\n                            let transcript = await youtubeService.getTranscript(\n                                videoId\n                            );\n\n                            // Check if the result is a caption URL that needs to be fetched\n                            if (transcript.startsWith(\"CAPTION_URL:\")) {\n                                console.log(\n                                    \"[Background] Received caption URL from page scraping\"\n                                );\n                                const captionUrl = transcript.substring(\n                                    \"CAPTION_URL:\".length\n                                );\n\n                                try {\n                                    // Fetch the caption URL\n                                    const response = await fetch(captionUrl);\n                                    if (response.ok) {\n                                        const captionText =\n                                            await response.text();\n\n                                        // Parse the XML caption data\n                                        if (captionText.includes(\"<text \")) {\n                                            // Simple XML parsing to extract captions\n                                            const parser = new DOMParser();\n                                            const xmlDoc =\n                                                parser.parseFromString(\n                                                    captionText,\n                                                    \"text/xml\"\n                                                );\n                                            const textElements =\n                                                xmlDoc.getElementsByTagName(\n                                                    \"text\"\n                                                );\n\n                                            let parsedTranscript = \"\";\n                                            for (\n                                                let i = 0;\n                                                i < textElements.length;\n                                                i++\n                                            ) {\n                                                const element = textElements[i];\n                                                const text =\n                                                    element.textContent || \"\";\n                                                const start =\n                                                    element.getAttribute(\n                                                        \"start\"\n                                                    );\n\n                                                if (text.trim() && start) {\n                                                    const seconds =\n                                                        parseFloat(start);\n                                                    const minutes = Math.floor(\n                                                        seconds / 60\n                                                    );\n                                                    const remainingSeconds =\n                                                        Math.floor(\n                                                            seconds % 60\n                                                        );\n                                                    const timestamp = `[${minutes\n                                                        .toString()\n                                                        .padStart(\n                                                            2,\n                                                            \"0\"\n                                                        )}:${remainingSeconds\n                                                        .toString()\n                                                        .padStart(2, \"0\")}]`;\n\n                                                    parsedTranscript += `${timestamp} ${text.trim()}\\n`;\n                                                }\n                                            }\n\n                                            if (parsedTranscript.trim()) {\n                                                transcript =\n                                                    parsedTranscript.trim();\n                                                console.log(\n                                                    \"[Background] Successfully parsed caption URL data\"\n                                                );\n                                            }\n                                        }\n                                    }\n                                } catch (captionError) {\n                                    console.error(\n                                        \"[Background] Error fetching caption URL:\",\n                                        captionError\n                                    );\n                                }\n                            }\n\n                            // Only create the Transcript node if we have a valid transcript\n                            if (transcript && transcript.trim()) {\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Valid transcript received, creating nodes\"\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript length:\",\n                                    transcript.length,\n                                    \"chars\"\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript preview:\",\n                                    transcript.substring(0, 100) + \"...\"\n                                );\n\n                                // Create Transcript node\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Creating parent Transcript node under article:\",\n                                    articleNodeId\n                                );\n                                const transcriptNodeId = await addClip(\n                                    articleNodeId,\n                                    \"Transcript\"\n                                );\n                                console.log(\n                                    \"[Background] Created Transcript node:\",\n                                    transcriptNodeId\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Parent Transcript node created successfully\"\n                                );\n\n                                // Add transcript text as child of Transcript node\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Adding transcript text as child of Transcript node:\",\n                                    transcriptNodeId\n                                );\n                                const transcriptTextNodeId = await addClip(\n                                    transcriptNodeId,\n                                    transcript\n                                );\n                                console.log(\n                                    \"[Background] Added transcript text node:\",\n                                    transcriptTextNodeId\n                                );\n                                console.log(\n                                    \"[TRANSCRIPT DEBUG] Transcript text node created successfully with ID:\",\n                                    transcriptTextNodeId\n                                );\n\n                                if (tab.id) {\n                                    await showNotification(\n                                        tab.id,\n                                        \"Saved page with transcript to My Highlights\"\n                                    );\n                                }\n                            } else {\n                                console.log(\n                                    \"[Background] No valid transcript found, not creating Transcript node\"\n                                );\n                                if (tab.id) {\n                                    await showNotification(\n                                        tab.id,\n                                        \"Saved page to My Highlights\"\n                                    );\n                                }\n                            }\n                        } catch (transcriptError) {\n                            console.error(\n                                \"[Background] All transcript fetching approaches failed:\",\n                                transcriptError\n                            );\n\n                            // Show a detailed error message so we can debug the issue\n                            const errorMessage =\n                                transcriptError instanceof Error\n                                    ? transcriptError.message\n                                    : String(transcriptError);\n\n                            console.error(\n                                \"[Background] Transcript error details:\",\n                                errorMessage\n                            );\n\n                            // Create a transcript node with the error information for debugging\n                            try {\n                                const transcriptNodeId = await addClip(\n                                    articleNodeId,\n                                    \"Transcript (Error Details)\"\n                                );\n\n                                await addClip(\n                                    transcriptNodeId,\n                                    `Transcript extraction failed with error: ${errorMessage}\\n\\nThis is a debug node to help diagnose the issue.`\n                                );\n\n                                console.log(\n                                    \"[Background] Created transcript error debug node:\",\n                                    transcriptNodeId\n                                );\n                            } catch (debugNodeError) {\n                                console.error(\n                                    \"[Background] Failed to create debug node:\",\n                                    debugNodeError\n                                );\n                            }\n\n                            // Don't create a real transcript node since extraction failed\n                            if (tab.id) {\n                                await showNotification(\n                                    tab.id,\n                                    `Saved page to My Highlights (transcript error: ${errorMessage.substring(\n                                        0,\n                                        50\n                                    )}${errorMessage.length > 50 ? \"...\" : \"\"})`\n                                );\n                            }\n                        }\n                    } else {\n                        console.log(\n                            \"[Background] Transcript node already exists, skipping transcript fetch\"\n                        );\n                        if (tab.id) {\n                            await showNotification(\n                                tab.id,\n                                \"Page saved to My Highlights\"\n                            );\n                        }\n                    }\n                } catch (error) {\n                    console.error(\n                        \"[Background] Error processing YouTube transcript:\",\n                        error\n                    );\n                    // Continue with normal page save even if transcript fails\n                    if (tab.id) {\n                        await showNotification(\n                            tab.id,\n                            \"Saved page to My Highlights (transcript unavailable)\"\n                        );\n                    }\n                }\n            } else {\n                console.log(\n                    \"[Background] Page captured via keyboard shortcut. Article node id:\",\n                    articleNodeId\n                );\n                if (tab.id) {\n                    await showNotification(\n                        tab.id,\n                        \"Page saved to My Highlights\"\n                    );\n                }\n            }\n        } catch (err) {\n            console.error(\n                \"[Background] Error processing clipPage command:\",\n                err\n            );\n            const tabs = await chrome.tabs.query({\n                active: true,\n                currentWindow: true,\n            });\n            if (tabs && tabs[0] && tabs[0].id) {\n                await showNotification(\n                    tabs[0].id,\n                    \"Error saving page to My Highlights\"\n                );\n            }\n        }\n    }\n});\n\n// Export the functionality\nexport { injectNotificationSystem, showNotification };\n"],
  "mappings": "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",
  "names": ["node", "logger", "transcriptButton", "i", "showNotification"]
}
