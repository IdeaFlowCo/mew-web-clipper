{
  "version": 3,
  "sources": ["../services/xmlParser.ts"],
  "sourcesContent": ["/* xmlParser.ts - Content script for XML parsing */\n\n// Function to parse XML text into a document\nexport function parseXML(xmlText: string): Document {\n    const parser = new DOMParser();\n    return parser.parseFromString(xmlText, \"text/xml\");\n}\n\n// Function to extract text content from XML document\nexport function extractTextFromXML(xmlDoc: Document): string {\n    // Try different tag names that YouTube might use for captions\n    const possibleTagNames = [\"text\", \"transcript\", \"caption\", \"p\"];\n    let textElements: HTMLCollectionOf<Element> | null = null;\n\n    // Find the first tag name that has elements\n    for (const tagName of possibleTagNames) {\n        const elements = xmlDoc.getElementsByTagName(tagName);\n        if (elements.length > 0) {\n            textElements = elements;\n            console.log(\n                `[XML Parser] Found ${elements.length} elements with tag name: ${tagName}`\n            );\n            break;\n        }\n    }\n\n    // If no elements found with any of the tag names, try a more generic approach\n    if (!textElements || textElements.length === 0) {\n        console.log(\n            \"[XML Parser] No text elements found with standard tags, trying all elements\"\n        );\n        // Get all elements and filter for those that might contain text\n        const allElements = xmlDoc.getElementsByTagName(\"*\");\n        const textContainingElements: Element[] = [];\n\n        for (let i = 0; i < allElements.length; i++) {\n            const element = allElements[i];\n            if (element.textContent && element.textContent.trim()) {\n                textContainingElements.push(element);\n            }\n        }\n\n        if (textContainingElements.length > 0) {\n            console.log(\n                `[XML Parser] Found ${textContainingElements.length} elements with text content`\n            );\n            // Create a transcript from all text-containing elements\n            let transcript = \"\";\n            for (let i = 0; i < textContainingElements.length; i++) {\n                const text = textContainingElements[i].textContent || \"\";\n                if (text.trim()) {\n                    transcript += text.trim() + \"\\\\n\";\n                }\n            }\n            return transcript.trim();\n        }\n\n        console.log(\n            \"[XML Parser] No text-containing elements found in the document\"\n        );\n        return \"No text content found in the XML document.\";\n    }\n\n    // Process the found text elements\n    let transcript = \"\";\n    for (let i = 0; i < textElements.length; i++) {\n        const element = textElements[i];\n        const text = element.textContent || \"\";\n\n        if (text.trim()) {\n            // Check if the element has a start attribute (timestamp)\n            const start = element.getAttribute(\"start\");\n            if (start) {\n                // Format timestamp as [MM:SS]\n                const seconds = parseFloat(start);\n                const minutes = Math.floor(seconds / 60);\n                const remainingSeconds = Math.floor(seconds % 60);\n                const timestamp = `[${minutes\n                    .toString()\n                    .padStart(2, \"0\")}:${remainingSeconds\n                    .toString()\n                    .padStart(2, \"0\")}]`;\n\n                transcript += `${timestamp} ${text.trim()}\\\\n`;\n            } else {\n                transcript += text.trim() + \"\\\\n\";\n            }\n        }\n    }\n\n    return transcript.trim();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,WAAS,SAAS,SAA2B;AAChD,UAAM,SAAS,IAAI,UAAU;AAC7B,WAAO,OAAO,gBAAgB,SAAS,UAAU;AAAA,EACrD;AAGO,WAAS,mBAAmB,QAA0B;AAEzD,UAAM,mBAAmB,CAAC,QAAQ,cAAc,WAAW,GAAG;AAC9D,QAAI,eAAiD;AAGrD,eAAW,WAAW,kBAAkB;AACpC,YAAM,WAAW,OAAO,qBAAqB,OAAO;AACpD,UAAI,SAAS,SAAS,GAAG;AACrB,uBAAe;AACf,gBAAQ;AAAA,UACJ,sBAAsB,SAAS,MAAM,4BAA4B,OAAO;AAAA,QAC5E;AACA;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,CAAC,gBAAgB,aAAa,WAAW,GAAG;AAC5C,cAAQ;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,cAAc,OAAO,qBAAqB,GAAG;AACnD,YAAM,yBAAoC,CAAC;AAE3C,eAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,cAAM,UAAU,YAAY,CAAC;AAC7B,YAAI,QAAQ,eAAe,QAAQ,YAAY,KAAK,GAAG;AACnD,iCAAuB,KAAK,OAAO;AAAA,QACvC;AAAA,MACJ;AAEA,UAAI,uBAAuB,SAAS,GAAG;AACnC,gBAAQ;AAAA,UACJ,sBAAsB,uBAAuB,MAAM;AAAA,QACvD;AAEA,YAAIA,cAAa;AACjB,iBAAS,IAAI,GAAG,IAAI,uBAAuB,QAAQ,KAAK;AACpD,gBAAM,OAAO,uBAAuB,CAAC,EAAE,eAAe;AACtD,cAAI,KAAK,KAAK,GAAG;AACb,YAAAA,eAAc,KAAK,KAAK,IAAI;AAAA,UAChC;AAAA,QACJ;AACA,eAAOA,YAAW,KAAK;AAAA,MAC3B;AAEA,cAAQ;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAGA,QAAI,aAAa;AACjB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAM,UAAU,aAAa,CAAC;AAC9B,YAAM,OAAO,QAAQ,eAAe;AAEpC,UAAI,KAAK,KAAK,GAAG;AAEb,cAAM,QAAQ,QAAQ,aAAa,OAAO;AAC1C,YAAI,OAAO;AAEP,gBAAM,UAAU,WAAW,KAAK;AAChC,gBAAM,UAAU,KAAK,MAAM,UAAU,EAAE;AACvC,gBAAM,mBAAmB,KAAK,MAAM,UAAU,EAAE;AAChD,gBAAM,YAAY,IAAI,QACjB,SAAS,EACT,SAAS,GAAG,GAAG,CAAC,IAAI,iBACpB,SAAS,EACT,SAAS,GAAG,GAAG,CAAC;AAErB,wBAAc,GAAG,SAAS,IAAI,KAAK,KAAK,CAAC;AAAA,QAC7C,OAAO;AACH,wBAAc,KAAK,KAAK,IAAI;AAAA,QAChC;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,WAAW,KAAK;AAAA,EAC3B;",
  "names": ["transcript"]
}
